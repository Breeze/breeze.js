(function (testFns) {

  var breeze = testFns.breeze;
  var core = breeze.core;
  var Enum = core.Enum;
  var MetadataStore = breeze.MetadataStore;
  var EntityManager = breeze.EntityManager;
  var AutoGeneratedKeyType = breeze.AutoGeneratedKeyType;
  var SaveOptions = breeze.SaveOptions;
  var EntityQuery = breeze.EntityQuery;
  var EntityKey = breeze.EntityKey;
  var EntityState = breeze.EntityState;
  var FilterQueryOp = breeze.FilterQueryOp;
  var handleFail = testFns.handleFail;

  var newEm = testFns.newEm;
  var wellKnownData = testFns.wellKnownData;

  module("save", {
    beforeEach: function (assert) {
      testFns.setup(assert, {
        metadataFn: function () {
          var regionType = testFns.metadataStore.getEntityType("Region");
          regionType.setProperties({ autoGeneratedKeyType: AutoGeneratedKeyType.KeyGenerator });
          var territoryType = testFns.metadataStore.getEntityType("Territory");
          territoryType.setProperties({ autoGeneratedKeyType: AutoGeneratedKeyType.KeyGenerator });
        }
      });
    },
    afterEach: function () {
    }
  });

  test("update with client concurrency update with null rowVersion", function (assert) {
    var done = assert.async();
    var cust, rowVersion;
    var em1 = newEm();

    em1.executeQuery(new EntityQuery("Customers").where("rowVersion", "==", null).take(1)).then(function (data) {
      cust = data.results[0];

      testFns.morphStringProp(cust, "contactName");
      rowVersion = cust.getProperty("rowVersion");
      return em1.saveChanges();
    }).then(function (sr) {
      var ents = sr.entities;
      ok(ents.length === 1, "1 record should have been saved");
      ok(cust.getProperty("rowVersion") == rowVersion + 1);
    }).fail(handleFail).fin(done);
  });

  test("update with client concurrency update with non-null rowVersion", function (assert) {
    var done = assert.async();
    var cust, rowVersion;
    var em1 = newEm();

    em1.executeQuery(new EntityQuery("Customers")
      .where("rowVersion", "!=", null)
      .where("companyName", "!=","error")
      .take(1)).then(function (data) {
      cust = data.results[0];

      testFns.morphStringProp(cust, "contactName");
      rowVersion = cust.getProperty("rowVersion");
      return em1.saveChanges();
    }).then(function (sr) {
      var ents = sr.entities;
      ok(ents.length === 1, "1 record should have been saved");
      ok(cust.getProperty("rowVersion") == rowVersion + 1);
    }).fail(handleFail).fin(done);
  });

  test("update order", function (assert) {
    var done = assert.async();
    var em = newEm();
    var q = new EntityQuery("Orders").where("customerID", "!=", null).take(1);
    var order;
    var customerId;
    em.executeQuery(q).then(function (data) {
      var orders = data.results;
      ok(orders.length == 1);
      order = orders[0];
      customerId = order.getProperty("customerID");
      var freight = order.getProperty("freight");
      var offset = (Math.random() * 2 | 0) ? .01 : -.01;
      order.setProperty("freight", freight + offset);
      return em.saveChanges();
    }).then(function (sr) {
      var entities = sr.entities;
      ok(entities.length == 1, "should have saved only 1");
      ok(entities[0] == order, "should be the same entity");
      ok(order.getProperty("customerID") != null, "customerID foreign key should not change on an update");

    }).fail(testFns.handleFail).fin(done);
  });

  test("insert multipart entity", function (assert) {
    var done = assert.async();
    var em = newEm();
    var product = createProduct(em);
    var order = createOrder(em);

    var orderID, orderDetail, productID, odOrderID, odProductID;
    em.saveChanges().then(function (sr0) {
      ok(sr0.entities.length == 2, "should have saved 2 entities");

      orderDetail = createOrderDetail(em, order, product);

      orderID = order.getProperty("orderID");
      productID = product.getProperty("productID");
      ok(orderID != 0, "orderID should not be 0");
      ok(productID != 0, "productID should not be 0");
      var odOrderID = orderDetail.getProperty("orderID");
      var odProductID = orderDetail.getProperty("productID");
      ok(orderID == odOrderID, "orderID's should be the same");
      ok(productID == odProductID, "productID's should be the same");
      return em.saveChanges().fail(function (e) {
        throw e;
      });
    }).then(function (sr) {
      ok(sr.entities.length == 1, "should have saved 1 entity");
      var orderIDx = order.getProperty("orderID");
      var productIDx = product.getProperty("productID");
      // ok(orderID != orderIDx, "orderID should have changed");
      // ok(productID != productIDx, "productID should have changed");
      var odOrderIDx = orderDetail.getProperty("orderID");
      var odProductIDx = orderDetail.getProperty("productID");
      ok(orderIDx == odOrderIDx, "new orderID's should be the same");
      ok(productIDx == odProductIDx, "new productID's should be the same");
      // hack should not be necessary.
      // orderDetail.setProperty("productID", productIDx);
      orderDetail.setProperty("unitPrice", 10);
      return em.saveChanges();
    }).then(function (sr2) {
      ok(sr2.entities.length == 1, "should have saved 1 entity");
    }).fail(handleFail).fin(done);

  });

  // bug is with fixup of the 2nd part of the pk
  test("insert multipart entity 2", function (assert) {
    var done = assert.async();
    var em = newEm();
    var order = createOrder(em);
    var product = createProduct(em);
    var orderDetail = createOrderDetail(em, order, product);

    var orderID = order.getProperty("orderID");
    var productID = product.getProperty("productID");
    ok(orderID != 0, "orderID should not be 0");
    ok(productID != 0, "productID should not be 0");
    var odOrderID = orderDetail.getProperty("orderID");
    var odProductID = orderDetail.getProperty("productID");
    ok(orderID == odOrderID, "orderID's should be the same");
    ok(productID == odProductID, "productID's should be the same");

    em.saveChanges().then(function (sr) {
      ok(sr.entities.length == 3, "should have saved 3 entities");
      ok(sr.entities.indexOf(product) >= 0, "should be the same product");
      ok(sr.entities.indexOf(order) >= 0, "should be the same order");
      ok(sr.entities.indexOf(orderDetail) >= 0, "should be the same orderDetail");
      var orderIDx = order.getProperty("orderID");
      var productIDx = product.getProperty("productID");
      ok(orderID != orderIDx, "orderID should have changed");
      ok(productID != productIDx, "productID should have changed");
      var odOrderIDx = orderDetail.getProperty("orderID");
      var odProductIDx = orderDetail.getProperty("productID");
      ok(orderIDx == odOrderIDx, "new orderID's should be the same");
      ok(productIDx == odProductIDx, "new productID's should be the same");
      // hack should not be necessary.
      // orderDetail.setProperty("productID", productIDx);
      orderDetail.setProperty("unitPrice", 10);
      return em.saveChanges();
    }).then(function (sr2) {
      ok(sr2.entities.length == 1, "should have saved 1 entity");
    }).fail(handleFail).fin(done);

  });

  test("hasChangesChanged event raised after saveChanges", 4, function (assert) {
    var done = assert.async();
    var em = newEm();

    var hasChangesChangedRaised = [];
    em.hasChangesChanged.subscribe(
        function (eventArgs) {
          hasChangesChangedRaised.push(eventArgs.hasChanges);
        }
    );

    var emp = em.createEntity("Employee");
    emp.setProperty("firstName", "Test fn");
    emp.setProperty("lastName", "Test ln");
    emp.setProperty("fullName", "foo");


    em.saveChanges()
      .then(function () {
        equal(hasChangesChangedRaised.length, 2,
            "hasChangesChanged should have been raised twice");
        ok(hasChangesChangedRaised[0] === true,
            "first hasChangesChanged is true after create");
        ok(hasChangesChangedRaised[1] === false,
            "second hasChangesChanged is false after save");
        ok(!em.hasChanges(),
            "manager should not have pending changes after save");
      }).fail(handleFail).fin(done);
  });

  test("should throw when delete saved added entity (store-gen key) before server save response", function (assert) {
    var done = assert.async();
    // Fails D#2649 "Internal Error in key fixup - unable to locate entity"
    var em = newEm();
    // Surround target emp (emp2) with other adds to see the effect on the cached adds
    var emp1 = em.createEntity("Employee", { firstName: 'Test fn1', lastName: 'Test ln1' });
    var emp2 = em.createEntity("Employee", { firstName: 'Test fn2', lastName: 'Test fn2' });
    var emp3 = em.createEntity("Employee", { firstName: 'Test fn3', lastName: 'Test fn3' });

    em.saveChanges()
    .then(function (sr) {
      ok(emp1.getProperty("employeeID") > -1, "emp1 should have a perm ID");
      ok(emp1.entityAspect.entityState.isUnchanged(), "emp1 should be in Unchanged state");
      ok(emp2.getProperty("employeeID") > -1, "emp2 should have a perm ID");
      ok(emp2.entityAspect.entityState.isUnchanged(), "emp2 should be in Unchanged state");
      ok(emp3.getProperty("employeeID") > -1, "emp3 should have a perm ID");
      ok(emp3.entityAspect.entityState.isUnchanged(), "emp3 should be in Unchanged state");
    })
    .catch(function (e) {
      var id1 = emp1.getProperty('employeeID'); // added state (wrong) but fixed up
      var id2 = emp2.getProperty('employeeID'); // detached with temp key
      var id3 = emp3.getProperty('employeeID'); // added state (wrong) with temp key (wrong)
      // D#2649: Break here to see partial processing and broken cache
      handleFail(e);
    })
    .finally(done);

    // try to delete the 2nd new employee before save can return;
    try {
      emp2.entityAspect.setDeleted();
    } catch (error) {
      // hope to trap error when call setDeleted() on added entity that is being saved.
    }
  });

  test("should throw when detach saved added entity (store-gen key) before server save response", function (assert) {
    var done = assert.async();
    // Fails D#2650 fixupKeys: "Internal Error in key fixup - unable to locate entity"
    var em = newEm();
    // Surround target emp (emp2) with other adds to see the effect on the cached adds
    var emp1 = em.createEntity("Employee", { firstName: 'Test fn1', lastName: 'Test ln1' });
    var emp2 = em.createEntity("Employee", { firstName: 'Test fn2', lastName: 'Test fn2' });
    var emp3 = em.createEntity("Employee", { firstName: 'Test fn3', lastName: 'Test fn3' });

    em.saveChanges()
    .then(function (sr) {
      ok(emp1.getProperty("employeeID") > -1, "emp1 should have a perm ID");
      ok(emp1.entityAspect.entityState.isUnchanged(), "emp1 should be in Unchanged state");
      ok(emp2.getProperty("employeeID") > -1, "emp2 should have a perm ID");
      ok(emp2.entityAspect.entityState.isUnchanged(), "emp2 should be in Unchanged state");
      ok(emp3.getProperty("employeeID") > -1, "emp3 should have a perm ID");
      ok(emp3.entityAspect.entityState.isUnchanged(), "emp3 should be in Unchanged state");
    })
    .catch(function (e) {
      var id1 = emp1.getProperty('employeeID'); // added state (wrong) but fixed up
      var id2 = emp2.getProperty('employeeID'); // detached with temp key
      var id3 = emp3.getProperty('employeeID'); // added state (wrong) with temp key (wrong)
      // D#2650: Break here to see partial processing and broken cache
      handleFail(e);
    })
    .finally(done);

    // try to detach the added entity before save can return;
    try {
      em.detachEntity(emp1);
    } catch (error) {
      // hope to trap error when call em.detachEntity on added entity that is being saved.
    }
  });

  test("should throw when call rejectChanges for saved added entity (store-gen key) before server save response", function (assert) {
    var done = assert.async();
    // Fails D#2649 fixupKeys: "Internal Error in key fixup - unable to locate entity"
    var em = newEm();
    // Surround target emp (emp2) with other adds to see the effect on the cached adds
    var emp1 = em.createEntity("Employee", { firstName: 'Test fn1', lastName: 'Test ln1' });
    var emp2 = em.createEntity("Employee", { firstName: 'Test fn2', lastName: 'Test fn2' });
    var emp3 = em.createEntity("Employee", { firstName: 'Test fn3', lastName: 'Test fn3' });

    em.saveChanges()
    .then(function (sr) {
      ok(emp1.getProperty("employeeID") > -1, "emp1 should have a perm ID");
      ok(emp1.entityAspect.entityState.isUnchanged(), "emp1 should be in Unchanged state");
      ok(emp2.getProperty("employeeID") > -1, "emp2 should have a perm ID");
      ok(emp2.entityAspect.entityState.isUnchanged(), "emp2 should be in Unchanged state");
      ok(emp3.getProperty("employeeID") > -1, "emp3 should have a perm ID");
      ok(emp3.entityAspect.entityState.isUnchanged(), "emp3 should be in Unchanged state");
    })
    .catch(function (e) {
      var id1 = emp1.getProperty('employeeID'); // added state (wrong) but fixed up
      var id2 = emp2.getProperty('employeeID'); // detached with temp key
      var id3 = emp3.getProperty('employeeID'); // added state (wrong) with temp key (wrong)
      // D#2650: Break here to see partial processing and broken cache
      handleFail(e);
    })
    .finally(done);

    // try to rejectChanges for the added entity before save can return;
    try {
      emp1.entityAspect.rejectChanges();
    } catch (error) {
      // hope to trap error when call em.detachEntity on added entity that is being saved.
    }
  });

  test("should throw when clear manager before server save response of saved added entity (store-gen key)", function (assert) {
    var done = assert.async();
    // Fails D#2650 fixupKeys: "Unable to locate the following fully qualified EntityType..."
    var em = newEm();
    var emp1 = em.createEntity("Employee", { firstName: 'Test fn1', lastName: 'Test ln1' });

    em.saveChanges()
    .then(function (sr) {
      ok(emp1.getProperty("employeeID") > -1, "emp1 should have a perm ID");
      ok(emp1.entityAspect.entityState.isUnchanged(), "emp1 should be in Unchanged state");
    })
    .catch(function (e) {
      var id1 = emp1.getProperty('employeeID'); // detached with temp key
      // D#2650: Break here to see state of emp.
      handleFail(e);
    })
    .finally(done);

    // try to clear the manager before save can return;
    try {
      em.clear();
    } catch (error) {
      // hope to trap error when call em.clear() when an added entity is being saved.
    }
  });

  test("can clear manager before server save response when no fixup needed", function (assert) {
    var done = assert.async();
    // See D#2650. What should be the behavior?
    var query = breeze.EntityQuery.from('Employees').take(1);
    var em = newEm(), emp1;
    em.executeQuery(query).then(function (data) {
      emp1 = data.results[0];
      emp1.entityAspect.setModified();
      var promise = em.saveChanges();

      // THE FATEFUL MOMENT
      // try to clear the manager before save can return;
      try {
        em.clear(); // should we throw?
      } catch (error) {
        // This would trap the error and assert that if we decided to throw
      }
      return promise;
    }).then(function (sr) {
      ok(sr.entities.length > 0, "Should have results");
      ok(emp1.entityAspect.entityState.isUnchanged(), "emp1 should be detached? unchanged?");
    }).catch(function (e) {
      var id1 = emp1 && emp1.getProperty('employeeID');
      // D#2650: Break here to see state of the emp.
      handleFail(e);
    }).finally(done);
  });

  // This test passes when the server returns the saved added entity as most servers do
  test("reverts to saved values when save an added entity then modify it before save response", function (assert) {
    var done = assert.async();
    var em = newEm();
    var emp1 = em.createEntity("Employee", { firstName: 'Test fn1', lastName: 'Test ln1' });

    em.saveChanges()
      .then(function (sr) {
        ok(sr.entities.length > 0, "Should have results");
        ok(emp1.entityAspect.entityState.isUnchanged(), "emp1 should be unchanged");
        equal(emp1.getProperty('firstName'), 'Test fn1', "firstName should have reverted to saved value.");
      })
      .catch(handleFail).finally(done);

    // modify it while save is in-flight
    emp1.setProperty('firstName', 'Test fn1 mod');
  });

  // This test passes when the server returns the saved entity
  // That won't be true for every server and therefore behavior can be different
  test("reverts to saved values when save modifed entity then modify it again before save response", function (assert) {
    var done = assert.async();
    var em = newEm();
    var emp1 = em.createEntity("Employee", { firstName: 'Test fn1', lastName: 'Test ln1' });

    em.saveChanges()
      .then(function (sr) {
        ok(sr.entities.length > 0, "Should have results for 'Add' save");
        emp1.setProperty('firstName', 'Test fn1 mod1');
        var promise = em.saveChanges(); // save modified emp

        // modify it again while save is in-flight
        emp1.setProperty('firstName', 'Test fn1 mod2');

        return promise;
      })
      .then(function (sr) {
        ok(sr.entities.length > 0, "Should have results for 'Mod' save");
        ok(emp1.entityAspect.entityState.isUnchanged(), "emp1 should be unchanged");
        equal(emp1.getProperty('firstName'), 'Test fn1 mod1', "firstName should have reverted to saved modified value.");
      })
      .catch(handleFail).finally(done);
  });

  // This test passes when the server returns the whole saved entity
  // That won't be true for servers that return patch values
  // rather than entire entities and therefore behavior can be different
  test("reverts to saved values when save modified entity then modify a different value before save response", function (assert) {
    var done = assert.async();
    var em = newEm();
    var emp1 = em.createEntity("Employee", { firstName: 'Test fn1', lastName: 'Test ln1' });

    em.saveChanges()
      .then(function (sr) {
        ok(sr.entities.length > 0, "Should have results for 'Add' save");
        emp1.setProperty('firstName', 'Test fn1 mod1');
        var promise = em.saveChanges(); // save modified emp

        // modify a different property while save is in-flight
        emp1.setProperty('lastName', 'Test ln1 mod2');

        return promise;
      })
      .then(function (sr) {
        ok(sr.entities.length > 0, "Should have results for 'Mod' save");
        ok(emp1.entityAspect.entityState.isUnchanged(), "emp1 should be unchanged");
        equal(emp1.getProperty('lastName'), 'Test ln1', "lastName should have reverted to original saved value.");
      })
      .catch(handleFail).finally(done);
  });

  // This test passes when the server returns the whole saved entity
  // That won't be true for servers that return patch values
  // rather than entire entities and therefore behavior can be different
  test("reverts to saved values when save modified entity then modify a different value before save response", function (assert) {
    var done = assert.async();
    var em = newEm();
    var emp1 = em.createEntity("Employee", { firstName: 'Test fn1', lastName: 'Test ln1' });

    em.saveChanges()
      .then(function (sr) {
        ok(sr.entities.length > 0, "Should have results for 'Add' save");
        emp1.setProperty('firstName', 'Test fn1 mod1');
        var promise = em.saveChanges(); // save modified emp

        // modify a different property while save is in-flight
        emp1.setProperty('lastName', 'Test ln1 mod2');

        return promise;
      })
      .then(function (sr) {
        ok(sr.entities.length > 0, "Should have results for 'Mod' save");
        ok(emp1.entityAspect.entityState.isUnchanged(), "emp1 should be unchanged");
        equal(emp1.getProperty('lastName'), 'Test ln1', "lastName should have reverted to original saved value.");
      })
      .catch(handleFail).finally(done);
  });

  test("manager.hasChanges() is true after save if manager other changes were made during save", function (assert) {
    var done = assert.async();
    // D#2651
    expect(2);
    var em = newEm();
    var emp1 = em.createEntity("Employee", { firstName: 'Test fn1', lastName: 'Test ln1' });

    em.saveChanges()
      .then(function (sr) {
        var hasChanges = em.hasChanges();
        var changes = em.getChanges();
        equal(changes.length, 1, "should have one pending change, the added emp2");
        ok(hasChanges, "'hasChanges()' should be true");
      })
      .catch(handleFail).finally(done);

    // Create another entity while save is in progress
    var emp2 = em.createEntity("Employee", { firstName: 'Test fn2', lastName: 'Test fn2' });

  });

  test("delete without query", function (assert) {
    var done = assert.async();
    var em = newEm();
    var em2 = newEm();
    var similarEmp;
    var similarAspect;
    var emp = em.createEntity("Employee");
    emp.setProperty("firstName", "Test fn");
    emp.setProperty("lastName", "Test ln");
    emp.setProperty("fullName", "foo");
    em.addEntity(emp);

    em.saveChanges().then(function (sr) {
      var savedEnts = sr.entities;
      ok(savedEnts.length === 1, "should have saved 1 entity");
      ok(emp === savedEnts[0], "should be same emp");
      var empKeyValue = emp.getProperty(testFns.employeeKeyName);
      var empKey = emp.entityAspect.getKey();
      var empVersion = emp.getProperty("rowVersion");
      similarEmp = em2.createEntity("Employee");
      similarEmp.setProperty(testFns.employeeKeyName, empKeyValue);
      similarEmp.setProperty("rowVersion", empVersion);
      similarAspect = similarEmp.entityAspect;
      similarAspect.setUnchanged();
      similarAspect.setDeleted();
      ok(similarAspect.entityState.isDeleted(), "should be deleted");
      return em2.saveChanges();
    }).then(function (sr) {
      var savedEnts = sr.entities;
      ok(savedEnts.length === 1, "should have saved 1 entity");
      ok(savedEnts[0] === similarEmp, "should be the same similarEmp");
      ok(similarAspect.entityState.isDetached(), "should be detached");
    }).fail(handleFail).fin(done);


  });

  testFns.skipIf("mongo", " can not handle this test as written").
  test("pk update should throw meaningful exception", function (assert) {
    var done = assert.async();

    var em = newEm();

    var q = new EntityQuery("Territories").orderBy("territoryID desc").take(1);

    var order;
    var freight;
    q.using(em).execute().then(function (data) {
      ok(data.results.length === 1, "should be one result");
      var terr = data.results[0];
      var id = terr.getProperty("territoryID");
      terr.setProperty("territoryID", id + 1);

      return em.saveChanges();
    }).then(function (sr) {
      ok(false, "should not get here");
    }).fail(function (e) {
      var isOk;
      if (testFns.DEBUG_HIBERNATE) {
        isOk = e.message.toLowerCase().indexOf("row was updated or deleted by another") >= 0;
      } else if (testFns.DEBUG_ASPCORE) {
        isOk = e.message.toLowerCase().indexOf("data may have been modified or") >= 0;
      } else {
        isOk = e.message.indexOf("part of the entity's key") > 0;
      }
      ok(isOk, "error message should mention why it failed");
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("mongo", " can not handle this test as written").
  test("product update active", function (assert) {
    var done = assert.async();
    updateProduct(4, done);
  });

  testFns.skipIf("mongo", " can not handle this test as written").
  test("product update discontinued", function (assert) {
    var done = assert.async();
    updateProduct(5, done);
  });

  function updateProduct(productId, done) {

    var em = newEm();

    var q = new EntityQuery("Products").where("productID", "eq", productId);

    var order;
    var freight;
    q.using(em).execute().then(function (data) {
      ok(data.results.length === 1, "should be one result");
      var product = data.results[0];
      var unitsInStock = product.getProperty("unitsInStock");
      product.setProperty("unitsInStock", unitsInStock + 10);
      return em.saveChanges();
    }).then(function (sr) {
      ok(true, "save succeeded");
    }).fail(function (e) {
      ok(false, "error on save: " + e.message);
    }).fail(handleFail).fin(done);
  }

  testFns.skipIf("mongo", " can not handle this test as written").
  test("add entity with enum and related - UserRole", function (assert) {
    var done = assert.async();

    var em = newEm();
    var roleId;
    var userId = 6;
    //var p2 = breeze.Predicate.create("userId", "ne", userId);
    //var p1 = breeze.Predicate.create("userRoles", "all", p2);
    var p2 = breeze.Predicate.create("userId", "==", userId);
    var p1 = breeze.Predicate.create("userRoles", "any", p2).not();

    var q = new EntityQuery("Roles").where(p1).take(1);

    q.using(em).execute().then(function (data) {
      ok(data.results.length === 1, "should be one result");
      var role = data.results[0];
      roleId = role.getProperty("id");

      var newUserRole = em.createEntity('UserRole', {
        userId: userId,
        roleId: roleId
      });

      return em.saveChanges();
    }).then(function (sr) {
      ok(true, "save succeeded");
      var resultRole = sr.entities[0];
      var roleId2 = resultRole.getProperty("roleId");
      ok(roleId2 === roleId, "roleIds match");
      var userId2 = resultRole.getProperty("userId");
      ok(userId2 === userId, "userIds match");

      // delete entity
      resultRole.entityAspect.setDeleted();
      return em.saveChanges();
    }).then(function (sr) {
      ok(true, "delete succeeded");
    }).fail(function (e) {
      ok(false, "error on save: " + e.message);
    }).fail(handleFail).fin(done);

  });

  testFns.skipIf("mongo,odata,sequelize", "does not yet support enums").
  test("new entity with enum", function (assert) {
    var done = assert.async();

    var em = newEm();
    var em2 = newEm();
    var roleType = em.metadataStore.getEntityType("Role");

    var aRole = em.createEntity("Role");
    var aRole2;
    aRole.setProperty("roleType", "Restricted");
    aRole.setProperty("name", "TEMP" + testFns.makeTempString(5));
    var ves = aRole.entityAspect.validateEntity();
    em.saveChanges().then(function (sr) {
      ok(sr.entities.length == 1, "should have saved (added) one entity");
      aRole.setProperty("roleType", "Guest");
      return em.saveChanges();
    }).then(function (sr2) {
      ok(sr2.entities.length == 1, "should have saved (modified) one entity");
      var q2 = EntityQuery.fromEntities(aRole);
      return em2.executeQuery(q2);
    }).then(function (data) {
      var roles = data.results;
      ok(roles.length == 1, "should have queried one entity");

      aRole2 = roles[0];
      var rt = aRole2.getProperty("roleType");
      ok(rt == "Guest", "value should be 'Guest'");
      // throw away 'set' because the object is going to be deleted anyway.
      aRole2.setProperty("roleType", "Restricted");
      aRole2.entityAspect.setDeleted();
      return em2.saveChanges();
    }).then(function (sr3) {
      ok(sr3.entities.length == 1, "should have deleted one entity");
      ok(aRole2.entityAspect.entityState.isDetached(), "should be detached");
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("odata", "does not support server interception or alt resources").
  test("exceptions thrown on server", function (assert) {
    var done = assert.async();

    var em = newEm();

    var q = new EntityQuery("Orders").take(1);

    var order;
    var freight;
    q.using(em).execute().then(function (data) {
      order = data.results[0];
      freight = order.getProperty("freight") + .5;
      order.setProperty("freight", freight);

      var so = new SaveOptions({ resourceName: "SaveAndThrow", tag: "SaveAndThrow" });

      return em.saveChanges(null, so);
    }).then(function (sr) {
      ok("should not get here");
    }).fail(function (e) {
      ok(e);
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("mongo", "-employeeId is not an integer in this env").
  test("delete entity with Int32 property set to null", function (assert) {
    var done = assert.async();

    var em = newEm();
    var c1 = em.createEntity("Order", { employeeID: 1 });

    //save entity with non-null value on Int32 field
    em.saveChanges().then(function (sr) {
      var order = sr.entities[0];
      var empID0 = order.getProperty(testFns.employeeKeyName);
      ok(empID0 != null, "empID0 should not be null");

      //set the Int32 field to null
      order.setProperty(testFns.employeeKeyName, null);
      //resave entity
      return em.saveChanges();
    }).then(function (sr) {
      var order = sr.entities[0];
      var empID1 = order.getProperty(testFns.employeeKeyName);
      ok(empID1 === null, "value should be null");

      //mark entity as deleted
      order.entityAspect.setDeleted();
      //resave (i.e. delete) entity - the error should occur past this point
      return em.saveChanges();
    }).then(function (sr) {
      ok(true);
    }).fail(handleFail).fin(done);
  });

  // Breeze does not YET support an option to requery after save.
  // When it does let's resurrect this test.
  //test("check if save requeried saved entities", function(assert) {
  //    var em = newEm();
  //    var c1 = em.createEntity("TimeGroup", { comment: "trigger" });
  //
  //    em.saveChanges().then(function (sr) {
  //        var comment = sr.entities[0].comment;
  //        ok(comment === "happy", "should have requeried the value updated by trigger");
  //    }).fail(handleFail).fin(done);
  //});

  testFns.skipIf("mongo", "does not YET have a SaveCheck implemented on the server").
  test("check unmapped property on server", function (assert) {
    var done = assert.async();

    var em = newEm(MetadataStore.importMetadata(testFns.metadataStore.exportMetadata()));
    var customerType = em.metadataStore.getEntityType("Customer");

    var Customer = testFns.makeEntityCtor(function () {
      this.myUnmappedProperty = "anything22";
    });
    em.metadataStore.registerEntityTypeCtor("Customer", Customer);


    var cust = customerType.createEntity();
    cust.setProperty("companyName", "Test_compName");
    em.addEntity(cust);

    var entitiesToSave = new Array(cust);
    var saveOptions = new SaveOptions({ resourceName: "SaveCheckUnmappedProperty" });


    em.saveChanges(entitiesToSave, saveOptions).then(function (sr) {
      ok(true);
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("mongo", "does not YET have a SaveCheck implemented on the server").
  test("unmapped property serialization on server", function (assert) {
    var done = assert.async();

    var em = newEm(MetadataStore.importMetadata(testFns.metadataStore.exportMetadata()));
    var customerType = em.metadataStore.getEntityType("Customer");
    customerType.setProperties({
      serializerFn: function (dp, value) {
        if (typeof (value) === "string") return value.toUpperCase();
        if (dp.isUnmapped) {
          if (dp.name == "anotherOne") {
            value.extra = 666;
          }
        }
        return value;
      }
    });
    var Customer = testFns.makeEntityCtor(function () {
      this.myUnmappedProperty = "anything22";
      var x = {
        x: "22",
        y: "test",
        z: ["a1", 3, true, null, undefined, { foo: 4 }, function (x, y, z) {
          return 666
        }],
        testFn: function (a, b) {
          return a + b;
        }
      }
      x.recursive = { ok: true, notOk: x }; // notOk should not get serialized.
      this.anotherOne = x;
    });
    em.metadataStore.registerEntityTypeCtor("Customer", Customer);


    var cust = customerType.createEntity();
    cust.setProperty("companyName", "Test_compName");
    em.addEntity(cust);

    var entitiesToSave = new Array(cust);
    var saveOptions = new SaveOptions({ resourceName: "SaveCheckUnmappedPropertySerialized" });


    em.saveChanges(entitiesToSave, saveOptions).then(function (sr) {
      ok(true);
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("mongo", "does not YET have a SaveCheck implemented on the server").
  test("unmapped property suppression", function (assert) {
    var done = assert.async();

    var em = newEm(MetadataStore.importMetadata(testFns.metadataStore.exportMetadata()));
    var customerType = em.metadataStore.getEntityType("Customer");
    customerType.setProperties({
      serializerFn: function (dp, value) {
        if (dp.isUnmapped) return undefined;
        return value;
      }
    });
    var Customer = testFns.makeEntityCtor(function () {
      this.myUnmappedProperty = "anything22";
      var x = {
        x: "22",
        y: "test",
        z: ["a1", 3, true, null, undefined, { foo: 4 }]
      }
      x.recursive = { ok: true, notOk: x }; // notOk should not get serialized.
      this.anotherOne = x;
    });
    em.metadataStore.registerEntityTypeCtor("Customer", Customer);


    var cust = customerType.createEntity();
    cust.setProperty("companyName", "Test_compName");
    em.addEntity(cust);

    var entitiesToSave = new Array(cust);
    var saveOptions = new SaveOptions({ resourceName: "SaveCheckUnmappedPropertySuppressed" });


    em.saveChanges(entitiesToSave, saveOptions).then(function (sr) {
      ok(true);
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("mongo", "does not YET have a SaveCheck implemented on the server").
  test("check initializer is hit for entities added/saved on server", function (assert) {
    var done = assert.async();
    expect(2);
    var em = newEm(MetadataStore.importMetadata(testFns.metadataStore.exportMetadata()));
    var ordInitializer = function (ord) {
      ord.setProperty("shipCountry", "Brazil");
    };

    em.metadataStore.registerEntityTypeCtor("Order", null, ordInitializer);

    var emp = em.createEntity("Employee");
    emp.setProperty("firstName", "Test fn");
    emp.setProperty("lastName", "Test ln");
    emp.setProperty("fullName", "foo");
    em.addEntity(emp);
    var so = new SaveOptions({ resourceName: "SaveCheckInitializer" });

    em.saveChanges(null, so).then(function (sr) {
      var ents = sr.entities;
      ok(ents.length === 2, "since an Order was created/saved in the interceptor, length should be 2");
      ents.forEach(function(ent) {
        if (ent.entityType.shortName == "Order" ) {
          ok(ent.getProperty("shipCountry") === "Brazil", "initializer was not 'hit'");
        }
      })

    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("odata", "does not support server side interception or alt resource").
  skipIf("mongo", "test is not yet implemented because it requires a server side async call").
  test("entities retrieved on server being modified and resaved", function (assert) {
    var done = assert.async();
    var em = newEm();

    var q = EntityQuery.from("Categories").where("categoryName", "startsWith", "Beverage");

    em.executeQuery(q).then(function (data) {
      var category = data.results[0];
      testFns.morphStringProp(category, "categoryName");

      var entitiesToSave = new Array(category);
      var saveOptions = new SaveOptions({ tag: "increaseProductPrice" });
      return em.saveChanges(entitiesToSave, saveOptions);
    }).then(function (sr) {
      ok(sr.entities.length === 13, "13 records should have been saved - 1 category + 12 products");
      // TODO: we should now requery and check that the 12 products actually have increased in price.
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("odata", "does not support server interception or alt resources").
  test("data with additional entity added on server", function (assert) {
    var done = assert.async();

    var em = newEm();

    var supplier = em.createEntity("Supplier", { companyName: "CompName" });
    var entitiesToSave = new Array(supplier);
    var saveOptions = new SaveOptions({ tag: "addProdOnServer" });

    em.saveChanges(entitiesToSave, saveOptions).then(function (sr) {
      var addedProducts = em.getEntities(["Product"], EntityState.Added);

      ok(addedProducts.length === 0, "There should be no Added Products");
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("mongo", " does not allow primary keys to be shared between collections").
  test("can save a Northwind Order & InternationalOrder", function (assert) {
    var done = assert.async();

    // Create and initialize entity to save
    var em = newEm();

    var order = em.createEntity('Order', {
      customerID: wellKnownData.alfredsID,
      employeeID: wellKnownData.nancyID,
      shipName: "Test " + new Date().toISOString()
    });

    var internationalOrder = em.createEntity('InternationalOrder', {
      // I thought Jay fixed this?
      order: order, // sets OrderID and pulls it into the order's manager
      // orderID: order.getProperty("orderID"),
      customsDescription: "rare, exotic birds"
    });

    em.saveChanges().then(function (data) {

      var orderId = order.getProperty("orderID");
      var internationalOrderID = internationalOrder.getProperty("orderID");

      equal(internationalOrderID, orderId,
              "the new internationalOrder should have the same OrderID as its new parent Order, " + orderId);
      ok(orderId > 0, "the OrderID is positive, indicating it is a permanent order");

    }).fail(handleFail).fin(done);

  });

  testFns.skipIf("mongo", " does not allow primary keys to be shared between collections").
  test("can save a Northwind Order & OrderDetail", function (assert) {
    var done = assert.async();

    // Create and initialize entity to save
    var em = newEm();

    var order = em.createEntity('Order', {
      customerID: wellKnownData.alfredsID,
      employeeID: wellKnownData.nancyID,
      shipName: "Test " + new Date().toISOString()
    });

    var orderDetail1 = em.createEntity('OrderDetail', {
      order: order, // sets OrderID and pulls it into the order's manager
      productID: wellKnownData.chaiProductID, // wellKnownData.alfredsOrderDetailKey.ProductID
      quantity: 5
    });
    var orderDetail2 = em.createEntity('OrderDetail', {
      order: order, // sets OrderID and pulls it into the order's manager
      productID: wellKnownData.alfredsOrderDetailKey.ProductID,
      quantity: 6
    });

    em.saveChanges().then(function (data) {

      var orderId = order.getProperty("orderID");
      ok(orderId > 0, "orderID is positive");

    }).fail(handleFail).fin(done);

  });


  test("save with date as part of key", function (assert) {
    var done = assert.async();
    var em = newEm();
    var dt = new Date();
    dt.setUTCMilliseconds(100);
    var c1 = em.createEntity("Comment", { createdOn: dt, seqNum: 1, comment1: "now is the time for" });
    var c2 = em.createEntity("Comment", { createdOn: dt, seqNum: 2, comment1: "and again" });

    em.saveChanges().then(function (sr) {
      var comments = sr.entities;
      ok(comments.length === 2, "should have saved 2 comments");
      var em2 = newEm();
      var q = EntityQuery.from("Comments").where("createdOn", "==", dt);
      return em2.executeQuery(q);
    }).then(function (data) {
      var comments2 = data.results;
      ok(comments2.length === 2, "should have returned 2 comments");
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("mongo,sequelize,hibernate", "does not yet support computed properties").
  test("computed update", function (assert) {
    var done = assert.async();

    var em = newEm();
    var q = EntityQuery.from("Employees").take(3);

    em.executeQuery(q).then(function (data) {
      var emps = data.results;
      testFns.morphStringProp(emps[0], "lastName");
      return em.saveChanges();
    }).then(function (sr) {
      var ents = sr.entities;
      ok(ents.length === 1);
      var emp = ents[0];
      var fullName = emp.getProperty("lastName") + ", " + emp.getProperty("firstName");
      if (testFns.DEBUG_ODATA) {
        ok(fullName !== emp.getProperty("fullName"), "fullNames will not match with ODATA because no records are returned after save");
      } else {
        ok(fullName === emp.getProperty("fullName"), "fullNames do not match");
      }
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("mongo,sequelize,hibernate", "does not yet support computed properties").
  test("computed update - mod computed", function (assert) {
    var done = assert.async();

    var em = newEm();
    var q = EntityQuery.from("Employees").take(3);

    em.executeQuery(q).then(function (data) {
      var emps = data.results;
      testFns.morphStringProp(emps[0], "lastName");
      emps[0].setProperty("fullName", "xxx");
      return em.saveChanges();
    }).then(function (sr) {
      var ents = sr.entities;
      ok(ents.length === 1);
      var emp = ents[0];
      var fullName = emp.getProperty("lastName") + ", " + emp.getProperty("firstName");
      if (testFns.DEBUG_ODATA) {
        ok(fullName !== emp.getProperty("fullName"), "fullNames will not match with ODATA because no records are returned after save");
      } else {
        ok(fullName === emp.getProperty("fullName"), "fullNames do not match");
      }
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("mongo,sequelize,hibernate", "does not yet support computed properties").
  test("computed insert", function (assert) {
    var done = assert.async();
    var em = newEm();
    var emp = em.createEntity("Employee");
    emp.setProperty("firstName", "Test fn");
    emp.setProperty("lastName", "Test ln");
    emp.setProperty("fullName", "foo");
    em.addEntity(emp);

    em.saveChanges().then(function (sr) {
      var ents = sr.entities;
      ok(ents.length === 1);
      ok(ents[0] === emp, "should be the same emp");
      var fullName = emp.getProperty("lastName") + ", " + emp.getProperty("firstName");
      ok(fullName === emp.getProperty("fullName"), "fullNames do not match");


    }).fail(handleFail).fin(done);
  });

  test("update with unmapped changes", function (assert) {
    var done = assert.async();
    var em1 = newEm(testFns.newMs());
    var Customer = testFns.makeEntityCtor(function () {
      this.miscData = "asdf";
    });
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    var q = new EntityQuery("Customers").take(1);
    em1.executeQuery(q).then(function (data) {
      var custType = em1.metadataStore.getEntityType("Customer");
      var cust = data.results[0];
      var oldContactName = cust.getProperty("contactName");
      var oldMiscData = cust.getProperty("miscData");
      testFns.morphStringProp(cust, "contactName");
      testFns.morphStringProp(cust, "miscData");
      return em1.saveChanges();
    }).then(function (sr) {

      var e = sr.entities;
      ok(e.length === 1, "1 record should have been saved");
    }).fail(handleFail).fin(done);
  });

  // Test asserts will fail for OData until we fix #2574
  // "entityAspect.extraMetdata not preserved after export/import"
  test("update after exporting and reimporting a customer", function (assert) {
    var done = assert.async();
    var cust,
        em1 = newEm(testFns.newMs()),
        extraMetadata;


    new EntityQuery("Customers").take(1).using(em1).execute().then(function (data) {
      cust = data.results[0];

      if (testFns.DEBUG_ODATA) {
        extraMetadata = cust.entityAspect.extraMetadata;
        ok(extraMetadata,
            "has OData extraMetadata on the original customer before export");
      }

      var exported = em1.exportEntities([cust], { includeMetadata: false }); // exclude metadata ... not important
      cust.entityAspect.setDetached(); // remove from cache
      cust = em1.importEntities(exported).entities[0]; // get reimported customer

      if (testFns.DEBUG_ODATA) {
        // these tests fail for OData until #2574 fixed
        var xtra = cust.entityAspect.extraMetadata;
        ok(xtra, "has extraMetadata on the imported customer");
        equal(xtra.etag, extraMetadata.etag,
            "imported OData extraMetadata.etag matches original");
      }


      testFns.morphStringProp(cust, "contactName");
      // this will fail for OData until #2574 fixed because no etag
      return em1.saveChanges();
    }).then(function (sr) {
      var e = sr.entities;
      ok(e.length === 1, "1 record should have been saved");
    }).fail(handleFail).fin(done);
  });

  test("update with ES5 props and unmapped changes", function (assert) {
    var done = assert.async();
    var em1 = newEm(testFns.newMs());
    var Customer = testFns.models.CustomerWithES5Props();
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    var q = new EntityQuery("Customers").take(1);
    em1.executeQuery(q).then(function (data) {
      var custType = em1.metadataStore.getEntityType("Customer");
      var cust = data.results[0];
      var oldContactName = cust.getProperty("contactName");
      var oldMiscData = cust.getProperty("miscData");
      testFns.morphStringProp(cust, "contactName");
      testFns.morphStringProp(cust, "miscData");
      return em1.saveChanges();
    }).then(function (sr) {

      var e = sr.entities;
      ok(e.length === 1, "1 record should have been saved");
    }).fail(handleFail).fin(done);
  });

  test("delete with unmapped changes", function (assert) {
    var done = assert.async();
    var em1 = newEm(testFns.newMs());
    var Customer = testFns.makeEntityCtor(function () {
      this.miscData = "asdf";
    });
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    var zzz;
    em1.fetchMetadata().then(function () {
      zzz = createParentAndChildren(em1);
      return em1.saveChanges();
    }).then(function (saveResult) {
      var cust = zzz.cust1;
      var oldContactName = cust.getProperty("contactName");
      var oldMiscData = cust.getProperty("miscData");
      testFns.morphStringProp(cust, "contactName");
      testFns.morphStringProp(cust, "miscData");
      zzz.cust1.entityAspect.setDeleted();

      return em1.saveChanges();
    }).then(function (sr) {
      var r = sr.entities;
      ok(zzz.cust1.entityAspect.entityState.isDetached());
      ok(r.length === 3, "3 child records should have been modified ( stranded)");
    }).fail(handleFail).fin(done);


  });

  testFns.skipIf("odata", "does not support server interception or alt resources").
  test("with server reject", function (assert) {
    var done = assert.async();

    var em = newEm();

    var user = em.createEntity("Region");

    user.setProperty("regionDescription", "error here");
    em.addEntity(user);
    var hasChanges = em.hasChanges();
    ok(hasChanges, "should have some changes");

    em.saveChanges().then(function (sr) {
      ok(sr.entities.length == 0, "should not have saved anything");
      hasChanges = em.hasChanges();
      ok(hasChanges, "should still have some changes because user should have been rejected on the server");
      // var q2 = EntityQuery.fromEntities(order);
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("odata", "does not support server interception or alt resources").
  test("set audit field on user create", function (assert) {
    var done = assert.async();

    var em = newEm();
    var user = em.createEntity("User");
    user.setProperty("userName", "Test" + Date.now());
    user.setProperty("userPassword", "" + Date.now());
    user.setProperty("firstName", "Test");
    user.setProperty("lastName", "Test");
    user.setProperty("email", "test@test.com");

    em.addEntity(user);
    var hasChanges = em.hasChanges();
    ok(hasChanges, "should have some changes");
    var so = new SaveOptions({ resourceName: "SaveWithAuditFields" });

    em.saveChanges(null, so).then(function (sr) {
        ok(sr.entities.length == 1, "should have saved one entity");
      sr.entities.forEach(function (e) {
        ok(e.createdByUserId == 12345, "createdByUserId should equal value set on server");
      });
    }).fail(handleFail).fin(done);
  });

  test("user update", function (assert) {
    var done = assert.async();

    var em = newEm();
    var q = new EntityQuery("Users").where("id", "eq", 4);

    var user;
    var email = "u" + Date.now() + "@ideablade.com";
    q.using(em).execute().then(function (data) {
      user = data.results[0];
      user.setProperty("email", email);

      return em.saveChanges();
    }).then(function (sr) {
      ok(sr.entities.length == 1, "should have saved one entity");
      sr.entities.forEach(function (e) {
        ok(e.email == email, "email should equal new value");
      });
    }).fail(handleFail).fin(done);
  });


  testFns.skipIf("odata", "does not support server interception or alt resources").
  test("set audit field on user update", function (assert) {
    var done = assert.async();

    var em = newEm();
    var q = new EntityQuery("Users").where("id", "eq", 4);

    var user;
    q.using(em).execute().then(function (data) {
      user = data.results[0];
      user.setProperty("email", "u" + Date.now() + "@ideablade.com");

      var so = new SaveOptions({ resourceName: "SaveWithAuditFields" });

      return em.saveChanges(null, so);
    }).then(function (sr) {
      ok(sr.entities.length == 1, "should have saved one entity");
      sr.entities.forEach(function (e) {
        ok(e.modifiedByUserId == 12345, "modifiedByUserId should equal value set on server");
      });
    }).fail(handleFail).fin(done);
  });


  testFns.skipIf("odata", "does not support server interception or alt resources").
  test("with alt resource and server side add", function (assert) {
    var done = assert.async();

    var em = newEm();

    var q = new EntityQuery("Orders").where("shipCountry", "ne", null).take(1).orderBy("orderID");

    var order;
    var freight;
    q.using(em).execute().then(function (data) {
      order = data.results[0];
      freight = order.getProperty("freight") + .5;
      order.setProperty("freight", freight);

      var so = new SaveOptions({ resourceName: "SaveWithComment", tag: "SaveWithComment - order" });

      return em.saveChanges(null, so);
    }).then(function (sr) {
      ok(sr.entities.length == 2, "should have saved two entities");
      sr.entities.forEach(function (e) {
        ok(e.entityAspect, "entities should have an entityAspect after save");
      });
      var q2 = EntityQuery.fromEntities(order);
      return q2.using(em).execute();
    }).then(function (data2) {
      var order2 = data2.results[0];
      var freight2 = order2.getProperty("freight");
      ok(freight2 == freight, "freight2=" + freight2 + " vs " + freight);
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("odata", "does not support server interception or alt resources").
  test("with alt resource and server update", function (assert) {
    var done = assert.async();

    var em = newEm();

    var q = new EntityQuery("Orders").where("shipCountry", "ne", null).skip(1).take(1).orderBy("orderID");

    var order;
    var freight;
    q.using(em).execute().then(function (data) {
      order = data.results[0];
      freight = order.getProperty("freight") + .5;
      order.setProperty("freight", freight);

      var so = new SaveOptions({ resourceName: "SaveWithFreight2", tag: "freight update" });

      return em.saveChanges(null, so);
    }).then(function (sr) {
      ok(sr.entities.length == 1, "should have saved one entity");
      var q2 = EntityQuery.fromEntities(order);
      return q2.using(em).execute();
    }).then(function (data2) {
      var order2 = data2.results[0];
      var freight2 = order2.getProperty("freight");
      ok(freight2 == freight + 1, "freight2=" + freight2 + " vs " + (freight + 1));
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("odata", "does not support server interception or alt resources").
  test("with alt resource and server update - ForceUpdate", function (assert) {
    var done = assert.async();

    var em = newEm();

    var q = new EntityQuery("Orders").where("shipCountry", "ne", null).skip(2).take(1).orderBy("orderID");

    var order, freight, shipCountry;
    q.using(em).execute().then(function (data) {
      order = data.results[0];
      freight = order.getProperty("freight");
      shipCountry = testFns.morphString(order.getProperty("shipCountry"));
      order.setProperty("shipCountry", shipCountry);
      var so = new SaveOptions({ resourceName: "SaveWithFreight", tag: "freight update-force" });
      return em.saveChanges(null, so);
    }).then(function (sr) {
      ok(sr.entities.length == 1, "should have saved one entity");
      var q2 = EntityQuery.fromEntities(order);
      return q2.using(em).execute();
    }).then(function (data2) {
      var order2 = data2.results[0];
      var freight2 = order2.getProperty("freight");
      ok(freight2 == freight + 1, "freight2=" + freight2 + " vs " + (freight + 1));
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("odata", "does not support server interception or alt resources").
  test("with server update - original values fixup", function (assert) {
    var done = assert.async();

    var em = newEm();

    var q = new EntityQuery("Orders").where("shipCountry", "ne", null).skip(3).take(1).orderBy("orderID");

    var order, freight, shipCity;
    q.using(em).execute().then(function (data) {
      order = data.results[0];
      freight = order.getProperty("freight");
      shipCity = testFns.morphString(order.getProperty("shipCountry"));
      order.setProperty("shipCountry", shipCity);
      var so = new SaveOptions({ resourceName: "SaveWithFreight", tag: "freight update-ov" });
      return em.saveChanges(null, so);
    }).then(function (sr) {
      ok(sr.entities.length == 1, "should have saved one entity");
      var q2 = EntityQuery.fromEntities(order);
      return q2.using(em).execute();
    }).then(function (data2) {
      var order2 = data2.results[0];
      var freight2 = order2.getProperty("freight");
      ok(freight2 == freight + 1, "freight2=" + freight2 + " vs " + (freight + 1));
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("odata", "does not support server interception or alt resources").
  test("with saveOptions exit", function (assert) {
    var done = assert.async();

    var em = newEm();
    var zzz = createParentAndChildren(em);
    var cust1 = zzz.cust1;
    var so = new SaveOptions({ resourceName: "SaveWithExit", tag: "exit" });

    em.saveChanges(null, so).then(function (sr) {
      ok(sr.entities.length == 0);
    }).fail(handleFail).fin(done);

  });

  testFns.skipIf("odata", "does not support server interception or alt resources").
  skipIf("mongo", "has not yet implemented this").
  test("adds with EntityErrorsException", function (assert) {
    var done = assert.async();

    var em = newEm();
    var zzz = createParentAndChildren(em);
    var cust1 = zzz.cust1;
    var so = new SaveOptions({ resourceName: "SaveWithEntityErrorsException", tag: "entityErrorsException" });
    var order1ValErrorsChangedArgs = [];
    zzz.order1.entityAspect.validationErrorsChanged.subscribe(function (e) {
      order1ValErrorsChangedArgs.push(e);
    });

    em.saveChanges(null, so).then(function (sr) {
      ok(false, "should not get here");

    }).fail(function (e) {
      ok(e.message.indexOf("test of custom exception message")>=0, "wrong custom error message: " + e.message);
      ok(order1ValErrorsChangedArgs.length == 1, "should have had order1ValErrorsChangedArgs");
      ok(order1ValErrorsChangedArgs[0].added.length == 1, "should have added 1");
      ok(order1ValErrorsChangedArgs[0].removed.length == 0, "should have added 1");
      ok(e.entityErrors, "should have server errors");
      ok(e.entityErrors.length === 2, "2 order entities should have failed");
      ok(zzz.order1.entityAspect.getValidationErrors().length === 1);
      var order2Errs = zzz.order2.entityAspect.getValidationErrors();
      ok(order2Errs.length === 1, "should be 1 error for order2");
      ok(order2Errs[0].propertyName === "orderID", "errant property should have been 'orderID'");
      // now save it properly
      order1ValErrorsChangedArgs.length = 0;

      return em.saveChanges();
    }).then(function (sr) {
      ok(sr.entities.length === 4, "should have saved ok");
      ok(order1ValErrorsChangedArgs.length == 1, "should have had order1ValErrorsChangedArgs");
      ok(order1ValErrorsChangedArgs[0].added.length == 0, "should have removed 1");
      ok(order1ValErrorsChangedArgs[0].removed.length == 1, "should have removed 1");
    }).fail(handleFail).fin(done);

  });

  testFns.skipIf("odata", "does not support server interception or alt resources").
  skipIf("mongo", "has not yet implemented this").
  test("mods with EntityErrorsException", function (assert) {
    var done = assert.async();

    var em = newEm();
    var zzz = createParentAndChildren(em);
    var cust1 = zzz.cust1;


    em.saveChanges().then(function (sr) {
      zzz.cust1.setProperty("contactName", "foo");
      zzz.cust2.setProperty("contactName", "foo");
      zzz.order1.setProperty("freight", 888.11);
      zzz.order2.setProperty("freight", 888.11);
      ok(zzz.cust1.entityAspect.entityState.isModified(), "cust1 should be modified");
      ok(zzz.order1.entityAspect.entityState.isModified(), "order1 should be modified");
      var so = new SaveOptions({ resourceName: "SaveWithEntityErrorsException", tag: "entityErrorsException" });
      return em.saveChanges(null, so);
    }).then(function (sr2) {
      ok(false, "should not get here");
    }).fail(function (e) {
      ok(e.message == "test of custom exception message", "wrong custom error message: " + e.message);
      ok(e.entityErrors, "should have server errors");
      ok(e.entityErrors.length === 2, "2 order entities should have failed");
      ok(zzz.order1.entityAspect.getValidationErrors().length === 1);
      var order2Errs = zzz.order2.entityAspect.getValidationErrors();
      ok(order2Errs.length === 1, "should be 1 error for order2");
      ok(order2Errs[0].propertyName === "orderID", "errant property should have been 'orderID'");
      // now save it properly
      return em.saveChanges();
    }).then(function (sr) {
      ok(sr.entities.length === 4, "should have saved ok");
    }).fail(handleFail).fin(done);

  });

  test("with client side validation error", function (assert) {
    var done = assert.async();
    var em = newEm();
    var zzz = createParentAndChildren(em);
    var cust1 = zzz.cust1;
    cust1.setProperty("companyName", null);

    em.saveChanges().then(function (sr) {
      ok(false, "should not get here");
    }).fail(function (e) {
      ok(e.entityErrors, "should be a  entityError");
      ok(e.entityErrors.length === 1, "should be only one error");
      ok(!e.entityErrors[0].isServerError, "should NOT be a server error");
      var errors = cust1.entityAspect.getValidationErrors();
      ok(errors[0].errorMessage === errors[0].errorMessage, "error message should appear on the cust");

    }).fin(done);
  });

  testFns.skipIf("odata", "does not support server interception or alt resources").
  skipIf("mongo", "has not yet implemented this").
  // skipIf("hibernate", "is not applicable because this test uses EF validation annotations")
  test("with server side entity level validation error", function (assert) {
    var done = assert.async();
    var em = newEm();
    var zzz = createParentAndChildren(em);
    var cust1 = zzz.cust1;
    cust1.setProperty("companyName", "error");

    em.saveChanges().then(function (sr) {
      ok(false, "should not get here");
    }).fail(function (e) {
      ok(e.entityErrors, "should be a server error");
      ok(e.entityErrors.length === 1, "should be only one server error");
      var errors = cust1.entityAspect.getValidationErrors();
      ok(errors[0].errorMessage === e.entityErrors[0].errorMessage, "error message should appear on the cust");
    }).fin(done);
  });

  testFns.skipIf("odata", "does not support server interception or alt resources").
  skipIf("mongo", "has not yet implemented this").
  test("with server side entity level validation error + repeat", function (assert) {
    var done = assert.async();

    var em = newEm();
    var zzz = createParentAndChildren(em);
    var cust1 = zzz.cust1;
    cust1.setProperty("companyName", "error");

    em.saveChanges().then(function (sr) {
      ok(false, "should not get here");
    }).fail(function (e) {
      ok(e.entityErrors, "should be a server error");
      ok(e.entityErrors.length === 1, "should be only one server error");
      var errors = cust1.entityAspect.getValidationErrors();
      ok(errors.length === 1, "should only be 1 error");
      ok(errors[0].errorMessage === e.entityErrors[0].errorMessage, "error message should appear on the cust");
      return em.saveChanges();
    }).fail(function (e2) {
      ok(e2.entityErrors, "should be a server error");
      ok(e2.entityErrors.length === 1, "should be only one server error");
      var errors = cust1.entityAspect.getValidationErrors();
      ok(errors.length === 1, "should only be 1 error");
      ok(errors[0].errorMessage === e2.entityErrors[0].errorMessage, "error message should appear on the cust");
    }).fin(done);
  });


  test("delete unsaved entity", function (assert) {
    var done = assert.async();
    var realEm = newEm();
    ok(realEm.hasChanges() === false, "The entity manager must not have changes");
    var query = EntityQuery.from("Customers")
        .where(testFns.customerKeyName, "==", "729de505-ea6d-4cdf-89f6-0360ad37bde7");

    var cust;
    realEm.executeQuery(query).then(function (data) {
      cust = data.results[0];
      return cust.entityAspect.loadNavigationProperty("orders");
    }).then(function (data2) {
      var newOrder = realEm.createEntity("Order", {}, breeze.EntityState.Detached);
      var orders = cust.getProperty("orders");
      orders.push(newOrder);
      ok(newOrder.entityAspect.entityState.isAdded() === true, "The entity is Added");
      newOrder.entityAspect.setDeleted();
      ok(realEm.hasChanges() === false, "The entity manager must not  have changes");
      return realEm.saveChanges();
    }).then(function (sr) {
      ok(realEm.hasChanges() === false, "The entity manager must not have changes");
    }).fail(handleFail).fin(done);
  });

  test("bigsave", function (assert) {
    var done = assert.async();
    var em = newEm();
    var recentArgs;
    em.hasChangesChanged.subscribe(function (args) {
      recentArgs = args;
    });
    for (var i = 0; i < 20; i++) {
      var zzz = createParentAndChildren(em);
    }
    ok(recentArgs.hasChanges === true);


    var startMs = Date.now();
    var endMs;
    em.saveChanges().then(function (sr) {
      var r = sr.entities;
      ok(r.length == 80, "Length: " + r.length);
      endMs = Date.now();
      var elapsed = (endMs - startMs) / 1000;
      ok(elapsed, "Elapsed time: " + elapsed);
    }).fail(handleFail).fin(done);
  });

  test("bigsave many children", function (assert) {
    var done = assert.async();
    var em = newEm();
    var recentArgs;
    em.hasChangesChanged.subscribe(function (args) {
      recentArgs = args;
    });
    for (var i = 0; i < 5; i++) {
      var zzz = createParentAndManyChildren(em);
    }
    ok(recentArgs.hasChanges === true);


    var startMs = Date.now();
    var endMs;
    em.saveChanges().then(function (sr) {
      var r = sr.entities;
      ok(r.length > 100, "Length: " + r.length);
      endMs = Date.now();
      var elapsed = (endMs - startMs) / 1000;
      ok(elapsed, "Elapsed time: " + elapsed);
    }).fail(handleFail).fin(done);
  });

  test("noop", function (assert) {
    var done = assert.async();
    var em = newEm();
    var q = new EntityQuery("Customers");

    q.using(em).execute().then(function (data) {
      return em.saveChanges();
    }).then(function (sr) {
      ok(Array.isArray(sr.entities));
      ok(sr.entities.length == 0);
      ok(!em.hasChanges());
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("sequelize,hibernate", " is unsupported because MySQL does not support millisecond resolution").
  test("data with millseconds - UTC time - IE bug", function (assert) {
    var done = assert.async();


    var em = newEm();
    var dt = new Date(Date.parse("2012-12-17T13:35:15.690Z"));
    var offset = dt.getTimezoneOffset() * 60000;
    var dt1 = new Date(dt.getTime() - offset);
    var dt2 = new Date(dt.getTime() + offset);
    var ms = dt.getUTCMilliseconds();
    ok(ms === 690);
    var q = new EntityQuery("Orders").where("shippedDate", "!=", dt).take(1);

    var order;
    q.using(em).execute().then(function (data) {
      order = data.results[0];
      order.setProperty("shippedDate", dt);
      return em.saveChanges();
    }).then(function (sr) {
      ok(sr.entities.length == 1, "should have saved one entity");
      var sameOrder = sr.entities[0];
      ok(order === sameOrder, "should be the sameOrder");
      var sameDt = sameOrder.getProperty("shippedDate");
      ok(dt.getTime() === sameDt.getTime(), "should be the same date");
      var em2 = newEm();
      var q2 = EntityQuery.fromEntities(order);
      return q2.using(em2).execute();
    }).then(function (data2) {
      var order2 = data2.results[0];
      var sameDt2 = order2.getProperty("shippedDate");
      ok(dt.getTime() === sameDt2.getTime(), "should be the same date: " + dt.toString() + " != " + sameDt2.toString());
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("sequelize,hibernate", " is unsupported because MySQL does not support millisecond resolution").
  test("data with millseconds - local time", function (assert) {
    var done = assert.async();

    var em = newEm();
    // Date.parse("2012-12-17T13:35:15.690");
    var dt = new Date(2012, 11, 17, 13, 35, 15, 690); // local time
    var ms = dt.getMilliseconds();
    ok(ms === 690);
    var q = new EntityQuery("Orders").take(1);

    var order;
    q.using(em).execute().then(function (data) {
      order = data.results[0];
      order.setProperty("shippedDate", dt);
      return em.saveChanges();
    }).then(function (sr) {
      ok(sr.entities.length == 1, "should have saved one entity");
      var sameOrder = sr.entities[0];
      ok(order === sameOrder, "should be the sameOrder");
      var sameDt = sameOrder.getProperty("shippedDate");
      ok(dt.getTime() === sameDt.getTime(), "should be the same date");
      var em2 = newEm();
      var q2 = EntityQuery.fromEntities(order);
      return q2.using(em2).execute();
    }).then(function (data2) {
      var order2 = data2.results[0];
      var sameDt2 = order2.getProperty("shippedDate");
      ok(dt.getTime() === sameDt2.getTime(), "should be the same date: " + dt.toString() + " != " + sameDt2.toString());
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("sequelize,hibernate", " is unsupported because MySQL does not support millisecond resolution").
  test("custom data annotation validation", function (assert) {
    var done = assert.async();

    // This test will fail currently with the DATABASEFIRST_OLD define.
    // This is because ObjectContext.SaveChanges() does not automatically validate
    // entities. It must be done manually.
    var em = newEm();
    var q = new EntityQuery("Customers").skip(20).take(1).orderBy("contactName");

    var cust1;
    q.using(em).execute().then(function (data) {
      ok(data.results.length === 1);
      cust1 = data.results[0];
      var region = cust1.getProperty("contactName");
      var newRegion = region == "Error" ? "Error again" : "Error";
      cust1.setProperty("contactName", newRegion);
      return em.saveChanges();
    }).then(function (sr) {
      ok(false, "shouldn't get here - except with DATABASEFIRST_OLD");
    }).fail(function (error) {
      ok(error.entityErrors, "should be some server errors");
      ok(error.entityErrors.length === 1, "should be 1 server error");
      ok(error.entityErrors[0].errorMessage.indexOf("the word 'Error'") > 0, "incorrect error message");
      var custErrors = cust1.entityAspect.getValidationErrors();
      ok(error.entityErrors[0].errorMessage === custErrors[0].errorMessage);
      // ok(error.message.indexOf("the word 'Error'") > 0, "incorrect error message");
    }).fin(done);
  });

  test("date", function (assert) {
    var done = assert.async();
    var em = newEm();
    var q = new EntityQuery("Orders").where("orderDate", '!=', null).take(10);

    var order, orderDate, newOrderDate;
    q.using(em).execute().then(function (data) {
      var r = data.results;
      ok(r.length > 0, "should be some results");
      order = r[0];
      orderDate = order.getProperty("orderDate");
      ok(core.isDate(orderDate), "is not a date");
      var day = orderDate.getDate();
      day = day < 31 ? day + 1 : 1;
      newOrderDate = new Date(orderDate.getTime());
      newOrderDate.setDate(day);
      ok(core.isDate(newOrderDate), "is not a date");
      order.setProperty("orderDate", newOrderDate);
      return em.saveChanges();
    }).then(function (sr) {
      ok(Array.isArray(sr.entities));
      ok(sr.entities.length == 1);
      ok(!em.hasChanges());
      ok(sr.entities[0] === order, "should be same order");
      var newOrderDate2 = order.getProperty("orderDate");
      ok(core.isDate(newOrderDate2), "is not a date");
      ok(newOrderDate.getTime() == newOrderDate2.getTime());
      ok(orderDate != newOrderDate2);
    }).fail(handleFail).fin(done);
  });

  test("unmapped", function (assert) {
    var done = assert.async();

    // use a different metadata store for this em - so we don't polute other tests
    var em1 = newEm(testFns.newMs());
    var Customer = testFns.makeEntityCtor(function () {
      this.miscData = "asdf";
    });
    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    var q = new EntityQuery("Customers")
        .where("companyName", "startsWith", "C");
    q.using(em1).execute().then(function (data) {
      var customers = data.results;
      customers.every(function (c) {
        ok(c.getProperty("miscData") == "asdf", "miscData should == 'asdf'");

      });
      var cust = customers[0];
      cust.setProperty("miscData", "xxx");
      ok(cust.entityAspect.entityState == EntityState.Unchanged);
      ok(!em1.hasChanges(), "should not have changes");
      return em1.saveChanges();
    }).then(function (sr) {
      var saved = sr.entities;
      ok(saved.length === 0);
      ok(!em1.hasChanges());
    }).fail(handleFail).fin(done);
  });

  test("unmapped with ES5 props", function (assert) {
    var done = assert.async();

    // use a different metadata store for this em - so we don't polute other tests
    var em1 = newEm(testFns.newMs());
    var Customer = testFns.models.CustomerWithES5Props();

    em1.metadataStore.registerEntityTypeCtor("Customer", Customer);

    var q = new EntityQuery("Customers")
        .where("companyName", "startsWith", "C");
    q.using(em1).execute().then(function (data) {
      var customers = data.results;
      customers.every(function (c) {
        ok(c.getProperty("miscData") == "asdf", "miscData should == 'asdf'");

      });
      var cust = customers[0];
      cust.setProperty("miscData", "xxx");
      ok(cust.entityAspect.entityState == EntityState.Unchanged);
      ok(!em1.hasChanges(), "should not have changes");
      return em1.saveChanges();
    }).then(function (sr) {
      var saved = sr.entities;
      ok(saved.length === 0);
      ok(!em1.hasChanges());
    }).fail(handleFail).fin(done);
  });

  test("add parent and children", function (assert) {
    var done = assert.async();
    var em = newEm();
    var recentArgs;
    em.hasChangesChanged.subscribe(function (args) {
      recentArgs = args;
    });
    var zzz = createParentAndChildren(em);
    ok(recentArgs.hasChanges === true);

    em.saveChanges(null, null).then(function (saveResult) {
      ok(recentArgs.hasChanges === false);
      ok(zzz.cust1.entityAspect.entityState.isUnchanged());
      ok(zzz.cust2.entityAspect.entityState.isUnchanged());
      ok(zzz.order1.entityAspect.entityState.isUnchanged());
      ok(zzz.order2.entityAspect.entityState.isUnchanged());
      ok(zzz.cust1.getProperty(testFns.customerKeyName) != zzz.keyValues[0], "cust1.customerID should not match original values");
      ok(zzz.cust2.getProperty(testFns.customerKeyName) != zzz.keyValues[1], "cust2.customerID should not match original values");
      ok(zzz.order1.getProperty(testFns.orderKeyName) != zzz.keyValues[2]);
      ok(zzz.order2.getProperty(testFns.orderKeyName) != zzz.keyValues[3]);
      ok(zzz.order1.getProperty("customer") === zzz.cust1);
      ok(zzz.order2.getProperty("customer") === zzz.cust1);
      ok(zzz.cust1.getProperty("orders").length === 2);
      ok(zzz.cust2.getProperty("orders").length === 0);
      ok(!em.hasChanges());
    }).fail(handleFail).fin(done);
  });

  test("allow concurrent saves with concurrency column", function (assert) {
    var done = assert.async();
    var em = newEm();
    em.saveOptions = new SaveOptions({ allowConcurrentSaves: true });
    var q = new EntityQuery()
        .from("Customers")
        .take(2);


    em.executeQuery(q).then(function (data) {
      // query cust
      var cust = data.results[0];
      testFns.morphStringProp(cust, "companyName");

      return Promise.all([em.saveChanges(), em.saveChanges()]);
    }).then(function (x) {
      ok(false, "one save should have failed for concurrency reasons");
    }).fail(function (e) {
      var msg = e.message;
      if (msg.indexOf("Data may have been modified or")>=0) {
        ok(true, "got expected (EFCore) exception " + msg);
      } else if (msg.indexOf("Store update, insert") >= 0) {
        ok(true, "got expected (EF) exception " + msg);
      } else if (msg.indexOf("Row was updated or deleted by another transaction") >= 0) {
        ok(true, "got expected (Hibernate) exception " + msg);
      } else if (msg.indexOf("concurrency check") >= 0) {
        ok(true, "got expected (Mongo) exception " + msg);
      } else if (msg.indexOf("concurrency violation") >= 0) {
        ok(true, "got expected (Sequelize) exception " + msg);
      } else {
        ok(false, msg);
      }
    }).fin(done);

  });

  test("allow concurrent saves with NO concurrency column", function (assert) {
    var done = assert.async();
    var em = newEm();
    em.saveOptions = new SaveOptions({ allowConcurrentSaves: true });
    var q = new EntityQuery()
        .from("Products")
        .take(2);


    var prod;

    em.executeQuery(q).then(function (data) {
      // query cust
      prod = data.results[0];
      var price = prod.getProperty("unitPrice");
      prod.setProperty("unitPrice", price + .01);

      return Promise.all([em.saveChanges(), em.saveChanges()]);
    }).then(function (x) {
      ok(true, "expected both to succeed");
    }).fail(function (e) {
      ok(false, "both saves should have been ok but: " + e.message);
    }).fin(done);

  });

  test("disallow concurrent saves with NO concurrency column", function (assert) {
    var done = assert.async();
    var em = newEm();
    // Next line is not needed because it is the default
    // em.saveOptions = new SaveOptions({ allowConcurrentSaves: false });
    var q = new EntityQuery()
        .from("Products")
        .take(2);


    var prod;

    em.executeQuery(q).then(function (data) {
      // query cust
      prod = data.results[0];
      var price = prod.getProperty("unitPrice");
      prod.setProperty("unitPrice", price + .01);

      return Promise.all([em.saveChanges(), em.saveChanges()]);
    }).then(function (x) {
      ok(false, "expected only one to complete");
    }).fail(function (e) {
      if (e.message.indexOf("allowConcurrentSaves") >= 0) {
        ok(true, "got expected error: " + e.message);
      } else {
        ok(false, "unexpected error: " + e.message);
      }
    }).fin(done);

  });

  test("modify one", function (assert) {
    var done = assert.async();
    var em = newEm();
    var query = new EntityQuery()
        .from("Customers")
        .where("companyName", "startsWith", "C")
        .take(2);

    var newCompanyName, cust;
    em.executeQuery(query).then(function (data) {
      cust = data.results[0];
      var orders = cust.getProperty("orders");
      var companyName = cust.getProperty("companyName");
      newCompanyName = testFns.morphString(companyName);
      cust.setProperty("companyName", newCompanyName);
      return em.saveChanges();
    }).then(function (saveResult) {
      ok(!em.hasChanges());
      var entities = saveResult.entities;
      ok(entities.length === 1);
      ok(saveResult.keyMappings.length === 0);
      ok(entities[0] === cust);
      ok(cust.getProperty("companyName") === newCompanyName);
      ok(cust.entityAspect.entityState.isUnchanged());
      var q2 = EntityQuery.fromEntities(cust);
      return em.executeQuery(q2);
    }).then(function (data2) {
      var entities2 = data2.results;
      ok(entities2.length === 1);
      ok(entities2[0] === cust);
      ok(cust.getProperty("companyName") === newCompanyName);
    }).fail(handleFail).fin(done);
  });

  test("modify parent and children", function (assert) {
    var done = assert.async();
    var em = newEm();

    var cust, orders, newCompanyName;
    saveNewCustAndOrders(em).then(function (savedCust) {
      cust = savedCust;
      if (cust == null) {
        throw new Error("Test error - need a customer with orders");
      }
      var companyName = cust.getProperty("companyName");
      newCompanyName = testFns.morphStringProp(cust, "companyName");
      ok(cust.entityAspect.entityState.isModified(), "should be modified");
      orders = cust.getProperty("orders");
      orders.forEach(function (o) {
        testFns.morphStringProp(o, "shipName");
        ok(o.entityAspect.entityState.isModified(), "should be modified");
      });
      return em.saveChanges();
    }).then(function (saveResult) {
      ok(!em.hasChanges());
      var entities = saveResult.entities;
      ok(entities.length === 1 + orders.length, "wrong number of entities returned");
      ok(saveResult.keyMappings.length === 0, "no key mappings should be returned");

      entities.forEach(function (e) {
        ok(e.entityAspect.entityState.isUnchanged(), "entity is not in unchanged state");
        if (e.entityType === cust.entityType) {
          ok(e === cust, "cust does not match");
        } else {
          ok(orders.indexOf(e) >= 0, "order does not match");
        }
      });

      ok(cust.getProperty("companyName") === newCompanyName, "company name was not changed");
      ok(cust.entityAspect.entityState.isUnchanged(), "entityState should be unchanged");
      var q2 = EntityQuery.fromEntities(cust);

      return em.executeQuery(q2);
    }).then(function (data2) {
      var entities2 = data2.results;
      ok(entities2.length === 1, "should only get a single entity");
      ok(entities2[0] === cust, "requery does not match cust");
      ok(cust.getProperty("companyName") === newCompanyName, "company name was not changed on requery");
    }).fail(handleFail).fin(done);
  });



  test("delete parent, children stranded", function (assert) {
    var done = assert.async();
    var em = newEm();
    var zzz = createParentAndChildren(em);

    em.saveChanges().then(function (saveResult) {
      zzz.cust1.entityAspect.setDeleted();
      var order1custid = zzz.order1.getProperty("customerID");
      ok(order1custid == null, "cust id should have been null'd");
      return em.saveChanges();
    }).then(function (sr) {
      ok(true, "saved ok - children null'd");
      // this can occur if we have a foreign key constraint on customer.orders
      //}).fail(function (error) {
      //ok(em.hasChanges());
      //ok(error instanceof Error, "should be an error");
      //ok(error.message.indexOf("FOREIGN KEY") >= 0, "message should contain 'FOREIGN KEY'");
      //});
    }).fail(handleFail).fin(done);
  });

  test("delete parent, then clear", function (assert) {
    var done = assert.async();
    var em = newEm();
    var zzz = createParentAndChildren(em);

    em.saveChanges().then(function (saveResult) {
      ok(!em.hasChanges());
      zzz.cust1.entityAspect.setDeleted();
      zzz.order1.entityAspect.setDeleted();
      zzz.order2.entityAspect.setDeleted();
      ok(zzz.order1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
      ok(zzz.cust1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
      ok(em.hasChanges());
      return em.saveChanges();
    }).then(function (sr) {
      try {
        em.clear();

      } catch (e) {
        ok(false, "clear should not fail: " + e);
      }
    }).fail(handleFail).fin(done);
  });

  test("delete parent then delete children", function (assert) {
    var done = assert.async();
    var em = newEm();
    var zzz = createParentAndChildren(em);

    em.saveChanges().then(function (saveResult) {
      ok(!em.hasChanges());
      zzz.cust1.entityAspect.setDeleted();
      zzz.order1.entityAspect.setDeleted();
      zzz.order2.entityAspect.setDeleted();
      ok(zzz.order1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
      ok(zzz.cust1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
      ok(em.hasChanges());
      return em.saveChanges();
    }).then(function (sr) {
      ok(!em.hasChanges());
      ok(sr.entities.length === 3, "should be 3 entities saved");
      ok(zzz.order1.entityAspect.entityState.isDetached(), "order1 should be marked as detached");
      ok(zzz.order2.entityAspect.entityState.isDetached(), "order2 should be marked as detached");
      ok(zzz.cust1.entityAspect.entityState.isDetached(), "cust1 should be marked as detached");
    }).fail(handleFail).fin(done);
  });

  test("delete children then delete parent", function (assert) {
    var done = assert.async();
    var em = newEm();
    var zzz = createParentAndChildren(em);

    em.saveChanges().then(function (saveResult) {
      var orders = zzz.cust1.getProperty("orders");
      ok(zzz.order1 === orders[0]);
      var cust1a = zzz.order1.getProperty("customer");
      ok(cust1a === zzz.cust1);


      zzz.order1.entityAspect.setDeleted();
      zzz.order2.entityAspect.setDeleted();
      zzz.cust1.entityAspect.setDeleted();
      ok(zzz.order1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
      ok(zzz.cust1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
      return em.saveChanges();
    }).then(function (sr) {
      ok(!em.hasChanges());
      ok(sr.entities.length === 3, "should be 3 entities saved");
      ok(zzz.order1.entityAspect.entityState.isDetached(), "order1 should be marked as detached");
      ok(zzz.order2.entityAspect.entityState.isDetached(), "order2 should be marked as detached");
      ok(zzz.cust1.entityAspect.entityState.isDetached(), "cust1 should be marked as detached");
    }).fail(handleFail).fin(done);
  });

  test("delete children then delete parent after query", function (assert) {
    var done = assert.async();
    var em = newEm();
    var em2 = newEm();
    var zzz = createParentAndChildren(em);

    var cust;
    em.saveChanges().then(function (saveResult) {
      var q = EntityQuery.fromEntities(zzz.cust1);
      q = EntityQuery.from("Customers").where(q.wherePredicate);
      return em2.executeQuery(q);
    }).then(function (data) {
      // this step is to avoid having to do an expand above - allows this test to be used for Mongo as well.
      cust = data.results[0];
      return cust.entityAspect.loadNavigationProperty("orders");
    }).then(function (data2) {
      var orders = cust.getProperty("orders").slice(0);
      orders.forEach(function (o) {
        o.entityAspect.setDeleted();
      });
      cust.entityAspect.setDeleted();
      ok(orders[0].entityAspect.entityState.isDeleted(), "should be marked as deleted");
      ok(cust.entityAspect.entityState.isDeleted(), "should be marked as deleted");
      return em2.saveChanges();
    }).then(function (sr) {
      ok(!em2.hasChanges(), "em should have no changes");
      ok(sr.entities.length === 3, "should be 3 entities saved");
      sr.entities.forEach(function (e) {
        ok(e.entityAspect.entityState.isDetached(), "entity should be marked as detached");
      });
    }).fail(handleFail).fin(done);
  });

  test("delete children, leave parent alone", function (assert) {
    var done = assert.async();
    var em = newEm();
    var zzz = createParentAndChildren(em);

    em.saveChanges().then(function (saveResult) {
      zzz.order1.entityAspect.setDeleted();
      ok(zzz.cust1.getProperty("orders").length === 1, "should only be 1 order now");
      zzz.order2.entityAspect.setDeleted();
      ok(zzz.cust1.getProperty("orders").length === 0, "should be no orders now");
      ok(zzz.order1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
      ok(zzz.cust1.entityAspect.entityState.isUnchanged(), "should be unchanged");
      return em.saveChanges();
    }).then(function (sr) {
      ok(!em.hasChanges());
      ok(zzz.order1.entityAspect.entityState.isDetached(), "should be marked as detached");
      ok(zzz.cust1.getProperty("orders").length === 0, "should be no orders now");
    }).fail(handleFail).fin(done);
  });

  test("delete parent, move children", function (assert) {
    var done = assert.async();
    var em = newEm();
    var zzz = createParentAndChildren(em);

    em.saveChanges().then(function (saveResult) {
      zzz.cust1.entityAspect.setDeleted();
      zzz.order1.setProperty("customer", zzz.cust2);
      ok(zzz.order1.entityAspect.entityState.isModified(), "should be marked as modified");
      zzz.order2.setProperty("customer", zzz.cust2);
      ok(zzz.cust1.entityAspect.entityState.isDeleted(), "should be marked as deleted");
      return em.saveChanges();
    }).then(function (sr2) {
      ok(!em.hasChanges());
      ok(sr2.entities.length === 3);
      ok(zzz.cust1.entityAspect.entityState.isDetached(), "should be marked as detached");
      ok(zzz.order1.entityAspect.entityState.isUnchanged(), "should be marked as unchanged");
    }).fail(handleFail).fin(done);
  });

  test("concurrency violation", function (assert) {
    var done = assert.async();
    var em = newEm();
    var em2 = newEm();
    var q = new EntityQuery()
        .from("Customers")
        .take(2);


    var cust;
    var sameCust;
    em.executeQuery(q).then(function (data) {
      // query cust
      cust = data.results[0];
      var q2 = EntityQuery.fromEntities(cust);
      return em2.executeQuery(q2);
    }).then(function (data2) {
      // query same cust in dif em
      // and modify it and resave it
      ok(data2.results.length == 1, "should only have 1 result");
      sameCust = data2.results[0];
      ok(cust.entityAspect.getKey().equals(sameCust.entityAspect.getKey()), "should be the same key");
      testFns.morphStringProp(sameCust, "companyName");
      return em2.saveChanges();
    }).then(function (sr2) {
      testFns.morphStringProp(cust, "companyName");
      return em.saveChanges();
    }).then(function (sr2) {
      ok(false, "should not get here, save should have failed");
    }).fail(function (error) {
      ok(em.hasChanges(), "entityManager should still have changes pending after a save failure");
      var exceptionType = error.detail.ExceptionType.toLowerCase();
      ok((exceptionType.indexOf("concurrency") >= 0 || exceptionType.indexOf("staleobjectstate") >= 0), "wrong error message: " + error.detail.ExceptionType);
    }).fin(done);
  });


  //test("concurrency violation on delete", function(assert) {
  //    var done = assert.async();
  //    ok(false, "not yet implemented");
  //});

  test("insert of existing entity", function (assert) {
    var done = assert.async();
    var em = newEm();
    // need to use a resource that does NOT do autoGeneratedKeys
    var resourceName = testFns.DEBUG_MONGO ? "Products" : "OrderDetails";
    var q = new EntityQuery()
        .from(resourceName)
        .take(2);


    var em2;
    em.executeQuery(q).then(function (data) {
      var o = data.results[0];
      em.detachEntity(o);
      em2 = newEm();
      em2.addEntity(o);
      return em2.saveChanges();
    }).then(function (sr) {
      ok(false, "shouldn't get here");
    }).fail(function (error) {
      ok(em2.hasChanges());
      var frag;
      if (testFns.DEBUG_MONGO) {
        frag = "duplicate key error"
      } else if (testFns.DEBUG_SEQUELIZE) {
        frag = "SequelizeUniqueConstraintError".toLowerCase();
      } else if (testFns.DEBUG_HIBERNATE) {
        frag = "duplicate entry"
      } else {
        frag = "primary key constraint"
      }
      ok(error.message.toLowerCase().indexOf(frag) >= 0, "wrong error message: " + error.message);
    }).fin(done);
  });

  testFns.skipIf("mongo,hibernate,sequelize", "does not have a TimeGroup table").
  skipIf("odata", "does not support this feature").
  test("insert using existing entity re-attached", function (assert) {
    var done = assert.async();
    var em = newEm();
    var q = new EntityQuery()
        .from("TimeGroups")
        .take(2);
    var tg = "test";

    em.executeQuery(q).then(function (data) {

      if (data.results.length == 0) {
        tg = em.createEntity("TimeGroup", { comment: "trigger" });
      } else {
        tg = data.results[0];
        testFns.morphStringProp(tg, "comment");
      }
      return em.saveChanges();
    }).then(function (sr) {
      var tg1 = sr.entities[0];
      ok(tg1 == tg, "should be the same");

      em.detachEntity(tg);
      tg.Id = -1;
      em.attachEntity(tg, breeze.EntityState.Added);
      tg.setProperty("comment", "This was re-attached");
      return em.saveChanges();
    }).then(function (sr2) {
      ok(true, "save successful");
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("odata", "does not support custom server side key generation").
  test("insert with generated key", function (assert) {
    var done = assert.async();
    var em = newEm();

    var region1 = createRegion(em, "1");
    var k1 = region1.entityAspect.getKey();

    var region2 = createRegion(em, "2");
    var k2 = region2.entityAspect.getKey();


    em.saveChanges().then(function (data) {
      ok(!em.hasChanges());
      ok(data.entities.length === 2);
      ok(!region1.entityAspect.getKey().equals(k1));
      ok(!region2.entityAspect.getKey().equals(k2));
      return data;
    }).then(function (data2) {
      // curious about synchronous results
      ok(data2.entities.length == 2);
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("odata", "does not support custom server side key generation").
  test("insert uni (1-n) relationships with generated key", function (assert) {
    var done = assert.async();
    var em = newEm();

    var region1 = createRegion(em, "1");
    var k1 = region1.entityAspect.getKey();
    var terrs1 = region1.getProperty("territories");
    var terr1a = createTerritory(em, "test 1a");
    var terr1b = createTerritory(em, "test 1b");
    terrs1.push(terr1a);
    terrs1.push(terr1b);

    var region2 = createRegion(em, "2");
    var k2 = region2.entityAspect.getKey();
    var terrs2 = region2.getProperty("territories");
    var terr2a = createTerritory(em, "test 2a");
    var terr2b = createTerritory(em, "test 2b");
    terrs2.push(terr2a);
    terrs2.push(terr2b);

    ok(region1.getProperty("territories").length === 2, "should have two terrs");
    ok(region2.getProperty("territories").length === 2, "should have two terrs");


    var terrs1x, terrs2x, region1y, terrs1y;
    var em2 = newEm();
    em.saveChanges().then(function (data) {
      ok(!em.hasChanges());

      ok(data.entities.length === 6);
      ok(!region1.entityAspect.getKey().equals(k1));
      terrs1x = region1.getProperty("territories");
      ok(terrs1x === terrs1, "territories should be the same");
      ok(terrs1x.length == 2, "terrs1 - length should be 2");
      ok(!region2.entityAspect.getKey().equals(k2));
      terrs2x = region2.getProperty("territories");
      ok(terrs2x === terrs2, "territories should be the same");
      ok(terrs2x.length == 2, "terrs2 - length should be 2");
      ok(terrs2x[0].getProperty("regionID") === region2.getProperty(testFns.regionKeyName), "regionId should have been updated");
      // now move them all onto region1;
      terrs2x.slice(0).forEach(function (t) {
        t.setProperty("regionID", region1.getProperty(testFns.regionKeyName));
      });
      ok(terrs1x.length == 4, "terrs1x should now be length 4");
      ok(terrs2x.length == 0, "terrs2x should now be length 0");
      return em.saveChanges();
    }).then(function (sr2) {
      ok(sr2.entities.length == 2, "should have saved 2 recs");
      ok(terrs1x.length == 4, "terrs1x should now be length 4");
      ok(terrs2x.length == 0, "terrs2x should now be length 0");
      return EntityQuery.fromEntities(region1).using(em2).execute();
    }).then(function (data3) {
      region1y = data3.results[0];
      terrs1y = region1y.getProperty("territories");
      return terrs1y.load();
    }).then(function (data4) {
      ok(data4.results.length === 4, "should be 4 terrs");
      ok(terrs1y.length === 4, "terrs1y should be of length 4");

    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("odata", "does not support custom server side key generation").
  skipIf("mongo", "does not support 'expand'").
  test("insert uni (1-n) relationships with generated key - v2", function (assert) {
    var done = assert.async();

    var em = newEm();
    var em2 = newEm();

    var region1 = createRegion(em, "1");
    var k1 = region1.entityAspect.getKey();
    var terrs1 = region1.getProperty("territories");
    var terr1a = createTerritory(em, "test 1a");
    var terr1b = createTerritory(em, "test 1b");
    terr1a.setProperty("regionID", region1.getProperty(testFns.regionKeyName));
    terr1b.setProperty("regionID", region1.getProperty(testFns.regionKeyName));

    var region2 = createRegion(em, "2");
    var k2 = region2.entityAspect.getKey();
    var terrs2 = region2.getProperty("territories");
    var terr2a = createTerritory(em, "test 2a");
    var terr2b = createTerritory(em, "test 2b");
    terr2a.setProperty("regionID", region2.getProperty(testFns.regionKeyName));
    terr2b.setProperty("regionID", region2.getProperty(testFns.regionKeyName));

    ok(region1.getProperty("territories").length === 2, "should have two terrs");
    ok(region2.getProperty("territories").length === 2, "should have two terrs");

    var terrs1x, terrs2x, region1ID, region1y, terrs1y;


    em.saveChanges().then(function (data) {
      ok(!em.hasChanges());
      ok(data.entities.length === 6);
      ok(!region1.entityAspect.getKey().equals(k1));
      terrs1x = region1.getProperty("territories");
      ok(terrs1x === terrs1, "territories should be the same");
      ok(terrs1x.length == 2, "terrs1 - length should be 2");
      ok(!region2.entityAspect.getKey().equals(k2));
      terrs2x = region2.getProperty("territories");
      ok(terrs2x === terrs2, "territories should be the same");
      ok(terrs2x.length == 2, "terrs2 - length should be 2");
      ok(terrs2x[0].getProperty("regionID") === region2.getProperty(testFns.regionKeyName), "regionId should have been updated");
      // now move them all onto region1;
      terrs2x.slice(0).forEach(function (t) {
        terrs1x.push(t);
      });
      ok(terrs1x.length == 4, "terrs1x should now be length 4");
      ok(terrs2x.length == 0, "terrs2x should now be length 0");
      return em.saveChanges();
    }).then(function (sr2) {
      ok(sr2.entities.length == 2, "should have saved 2 recs");
      ok(terrs1x.length == 4, "terrs1x should now be length 4");
      ok(terrs2x.length == 0, "terrs2x should now be length 0");
      return EntityQuery.fromEntities(region1).expand("territories").using(em).execute();
    }).then(function (data3) {
      ok(data3.results.length === 1, "should be 1 region");
      ok(region1 === data3.results[0], "should be same region");
      ok(terrs1x.length === 4, "terrs1x should be of length 4");
      return EntityQuery.fromEntities(region1).expand("territories").using(em2).execute();
    }).then(function (data4) {
      ok(data4.results.length === 1, "should be 1 region");
      terrs1y = data4.results[0].getProperty("territories");
      ok(terrs1y.length === 4, "should still be 4 recs");
    }).fail(handleFail).fin(done);
  });

  testFns.skipIf("odata", "does not support custom server side key generation (except identity)").
  test("insert uni (1-n) relationships with unattached children - v3", function (assert) {
    var done = assert.async();

    var em = newEm();
    var em2 = newEm();

    var region1 = createRegion(em, "1");
    var k1 = region1.entityAspect.getKey();
    var terrs1 = region1.getProperty("territories");
    var terr1a = createTerritory(em, "test 1a");
    var terr1b = createTerritory(em, "test 1b");
    terr1a.setProperty("regionID", region1.getProperty(testFns.regionKeyName));
    terr1b.setProperty("regionID", region1.getProperty(testFns.regionKeyName));

    var region2 = createRegion(em, "2");
    var k2 = region2.entityAspect.getKey();
    var terrs2 = region2.getProperty("territories");
    var terr2a = createTerritory(em, "test 2a");
    var terr2b = createTerritory(em, "test 2b");
    terr2a.setProperty("regionID", region2.getProperty(testFns.regionKeyName));
    terr2b.setProperty("regionID", region2.getProperty(testFns.regionKeyName));

    ok(region1.getProperty("territories").length === 2, "should have two terrs");
    ok(region2.getProperty("territories").length === 2, "should have two terrs");
    var terrs1x, terrs2x, region1ID, region1y, terrs1y;



    em.saveChanges().then(function (data) {
      ok(!em.hasChanges());
      ok(data.entities.length === 6);
      ok(!region1.entityAspect.getKey().equals(k1));
      var territories = em.getEntities("Territory");
      return EntityQuery.fromEntities(territories).using(em2).execute();
    }).then(function (data2) {
      ok(data2.results.length === 4, "should be 4 recs");
      return EntityQuery.fromEntities(region1).using(em2).execute();
    }).then(function (data3) {
      ok(data3.results.length === 1, "should be 1 rec");
      var region1a = data3.results[0];
      var terrs1a = region1a.getProperty("territories");
      ok(terrs1a.length == 2, "should be 2 terrs in region1");
    }).fail(handleFail).fin(done);
  });

  test("save of deleted entity should not trigger validation", function (assert) {
    var done = assert.async();
    // TODO: OData bug here is because of region - AutoGeneratedKeyType
    var em = newEm();
    var cust = createCustomer(em);

    ok(em.hasChanges());
    em.saveChanges().then(function (sr) {
      ok(!em.hasChanges());
      ok(sr.entities.length === 1, "one entity should have been saved");
      ok(sr.entities[0] === cust, "save result should contain cust");
      cust.setProperty("companyName", "");
      cust.entityAspect.setDeleted();
      ok(em.hasChanges());
      return em.saveChanges();
    }).then(function (sr2) {
      ok(!em.hasChanges());
      ok(sr2.entities.length === 1, "one entity should have been saved");
      ok(sr2.entities[0] === cust, "save result should contain region");
      ok(cust.entityAspect.entityState.isDetached(), "cust should now be detached");
    }).fail(handleFail).fin(done);
  });

  test("bad save call", function () {
    var em = newEm();
    try {
      em.saveChanges(null, new SaveOptions(), "adfa");
    } catch (e) {
      ok(e.message.indexOf("callback") >= 0);
    }
    try {
      em.saveChanges(null, "adfa");
    } catch (e) {
      ok(e.message.indexOf("saveOptions") >= 0);
    }
    try {
      em.saveChanges("adfa");
    } catch (e) {
      ok(e.message.indexOf("entities") >= 0);
    }

  });

  testFns.skipIf("mongo", "does not support 'expand'").
  test("cleanup  test data", function (assert) {
    var done = assert.async();
    var em = newEm();
    var p = breeze.Predicate.create("companyName", FilterQueryOp.StartsWith, "Test")
        .or("companyName", FilterQueryOp.StartsWith, "foo");
    var q = EntityQuery.from("Customers").where(p).expand("orders"); // .take(50);

    em.executeQuery(q).then(function (data) {
      // var promises = [];
      em.saveOptions = new SaveOptions({ allowConcurrentSaves: true });
      data.results.forEach(function (cust) {
        var orders = cust.getProperty("orders").slice(0);
        orders.forEach(function (order) {
          //var details = order.getProperty("orderDetails");
          //details.forEach(function (detail) {
          //    detail.entityAspect.setDeleted();
          //});
          //var io = order.getProperty("internationalOrder");
          //if (io) {
          //    io.entityAspect.setDeleted();
          //}
          order.entityAspect.setDeleted();
        });
        cust.entityAspect.setDeleted();
        //var pr = em.saveChanges();
        //promises.push(pr);
      });
      // return Promise.all(promises);
      return em.saveChanges();

    }).then(function (sr) {

      ok(sr.entities.length, "deleted count:" + sr.entities.length);
    }).fail(handleFail).fin(done);
  });

  function createCustomer(em) {
    var metadataStore = em.metadataStore;
    var custType = metadataStore.getEntityType("Customer");
    var cust1 = custType.createEntity();
    cust1.setProperty("companyName", "Test_js_1");
    cust1.setProperty("city", "Oakland");
    cust1.setProperty("rowVersion", 13);
    cust1.setProperty("fax", "510 999-9999");
    em.addEntity(cust1);
    return cust1;
  }

  function saveNewCustAndOrders(em) {
    var metadataStore = em.metadataStore;
    var custType = metadataStore.getEntityType("Customer");
    var orderType = metadataStore.getEntityType("Order");
    var cust1 = custType.createEntity();
    cust1.setProperty("companyName", "Test_js_1");
    cust1.setProperty("city", "Oakland");
    cust1.setProperty("rowVersion", 13);
    cust1.setProperty("fax", "510 999-9999");
    em.addEntity(cust1);
    var order1 = orderType.createEntity();
    order1.setProperty("orderDate", new Date());
    var order2 = orderType.createEntity();
    var orders = cust1.getProperty("orders");
    order2.setProperty("orderDate", new Date());
    orders.push(order1);
    orders.push(order2);
    return em.saveChanges().then(function (data) {
      var results = data.results;
      ok(cust1.entityAspect.entityState.isUnchanged());
      return cust1;
    });
  }

  function createParentAndChildren(em) {
    var metadataStore = em.metadataStore;
    var custType = metadataStore.getEntityType("Customer");
    var orderType = metadataStore.getEntityType("Order");
    var cust1 = custType.createEntity();
    cust1.setProperty("companyName", "Test_js_1");
    cust1.setProperty("city", "Oakland");
    cust1.setProperty("rowVersion", 13);
    cust1.setProperty("fax", "510 999-9999");
    var cust2 = custType.createEntity();
    cust2.setProperty("companyName", "Test_js_2");
    cust2.setProperty("city", "Emeryville");
    cust2.setProperty("rowVersion", 1);
    cust2.setProperty("fax", "510 888-8888");
    em.addEntity(cust1);
    em.addEntity(cust2);
    var order1 = orderType.createEntity();
    order1.setProperty("orderDate", new Date());
    var order2 = orderType.createEntity();
    var orders = cust1.getProperty("orders");
    order2.setProperty("orderDate", new Date());
    orders.push(order1);
    orders.push(order2);
    var keyValues = [cust1.getProperty(testFns.customerKeyName),
                     cust2.getProperty(testFns.customerKeyName),
                     order1.getProperty(testFns.orderKeyName),
                     order2.getProperty(testFns.orderKeyName)];
    return {
      cust1: cust1,
      cust2: cust2,
      order1: order1,
      order2: order2,
      keyValues: keyValues
    };
  }

  function createParentAndManyChildren(em) {
    var metadataStore = em.metadataStore;
    var custType = metadataStore.getEntityType("Customer");
    var orderType = metadataStore.getEntityType("Order");
    var cust1 = custType.createEntity();
    cust1.setProperty("companyName", "Test_js_1");
    cust1.setProperty("city", "Oakland");
    cust1.setProperty("rowVersion", 13);
    cust1.setProperty("fax", "510 999-9999");
    em.addEntity(cust1);
    var orders = cust1.getProperty("orders");
    for (var i = 1; i < 50; i++) {
      var order1 = orderType.createEntity();
      order1.setProperty("shipRegion", "foo-region");
      orders.push(order1);
    }
  }

  function createOrder(em) {
    var orderType = em.metadataStore.getEntityType("Order");
    var order = orderType.createEntity();
    em.addEntity(order);
    order.setProperty("shipName", "Test_" + new Date().toDateString());
    return order;
  }

  function createProduct(em) {
    var productType = em.metadataStore.getEntityType("Product");
    var product = productType.createEntity();
    em.addEntity(product);
    product.setProperty("productName", "Test_" + new Date().toDateString());
    return product;
  }

  function createOrderDetail(em, order, product) {
    var odType = em.metadataStore.getEntityType("OrderDetail");
    var od = odType.createEntity();
    var orderID = order.getProperty("orderID");
    var productID = product.getProperty("productID");

    od.setProperty("orderID", orderID);
    od.setProperty("productID", productID);
    od.setProperty("quantity", 1);
    od.setProperty("unitPrice", 3.14);
    em.addEntity(od);
    return od;
  }

  function createRegion(em, descr) {
    var regionType = testFns.metadataStore.getEntityType("Region");
    var region = regionType.createEntity();

    region.setProperty("regionDescription", "Test-" + descr + "-" + new Date().toDateString());
    em.addEntity(region);
    return region;
  }

  function createTerritory(em, descr) {
    var territoryType = testFns.metadataStore.getEntityType("Territory");
    var territory = territoryType.createEntity();
    territory.setProperty("territoryDescription", "Test-" + descr + "-" + new Date().toDateString());
    em.addEntity(territory);
    return territory;
  }

})(breezeTestFns);