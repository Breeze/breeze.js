(function (testFns) {

  if (testFns.DEBUG_SEQUELIZE || testFns.DEBUG_ODATA || testFns.MONGO) {
    module("save - transaction", {});
    QUnit.skip("Mongo,OData and Sequelize do not yet support server side inteception or these endpoints have not yet been implemented.", function() {

    });
    return;
  };

  var breeze = testFns.breeze;
  var core = breeze.core;
  var Enum = core.Enum;

  var MetadataStore = breeze.MetadataStore;
  var EntityManager = breeze.EntityManager;
  var AutoGeneratedKeyType = breeze.AutoGeneratedKeyType;
  var SaveOptions = breeze.SaveOptions;
  var EntityQuery = breeze.EntityQuery;
  var EntityKey = breeze.EntityKey;
  var EntityState = breeze.EntityState;
  var FilterQueryOp = breeze.FilterQueryOp;

  var newEm = testFns.newEm;

  var wellKnownData = testFns.wellKnownData;
  

  module("save - transaction", {
    beforeEach: function (assert) {
      testFns.setup(assert, {
        metadataFn: function () {
          var regionType = testFns.metadataStore.getEntityType("Region");
          regionType.setProperties({ autoGeneratedKeyType: AutoGeneratedKeyType.KeyGenerator });
          var territoryType = testFns.metadataStore.getEntityType("Territory");
          territoryType.setProperties({ autoGeneratedKeyType: AutoGeneratedKeyType.KeyGenerator });
        }
      });
    },
    afterEach: function () {
    }
  });


  function saveOrderAndAddShipAddressToComment(assert, resourceName) {
    var done = assert.async();
    var em = newEm();
    var testAddress = "Test " + new Date().toISOString();

    var order = em.createEntity('Order', {
      customerID: wellKnownData.alfredsID,
      employeeID: wellKnownData.nancyID,
      shipAddress: testAddress
    });
    var saveOptions = new SaveOptions({ resourceName: resourceName, tag: "CommentOrderShipAddress.Before" });
    
    em.saveChanges(null, saveOptions).then(function (data) {
      // BeforeSaveEntities should have put the testAddress in a comment
      var em2 = newEm();
      var q = EntityQuery.from("Comments").where("comment1", "==", testAddress);
      return em2.executeQuery(q);
    }).then(function (data) {
      var results = data.results;
      ok(results.length === 1, "should have returned 1 result");
      var comment = results[0];
      var comment1 = comment.getProperty("comment1");
      ok(comment1 === testAddress, "comment should equal testAddress");

    }).fail(testFns.handleFail).fin(done);
  }

  testFns.skipIf("hibernate", "does not YET support saving without a transaction").
  test("save Order and add ShipAddress to Comment in BeforeSave - SaveWithNoTransaction", function(assert) {
      saveOrderAndAddShipAddressToComment(assert, "SaveWithNoTransaction");
    });

  test("save Order and add ShipAddress to Comment in BeforeSave - SaveWithDbTransaction", function(assert) {
      saveOrderAndAddShipAddressToComment(assert, "SaveWithDbTransaction");
    });

  testFns.skipIf("hibernate", "does not distinguish between different types of transaction support").
  test("save Order and add ShipAddress to Comment in BeforeSave - SaveWithTransactionScope", function(assert) {
      saveOrderAndAddShipAddressToComment(assert, "SaveWithTransactionScope");
    });

  function saveOrderAndUpdateShipAddressBeforeSave(assert, resourceName) {
    var done = assert.async();
    var em = newEm();
    var testAddress = "Test " + new Date().toISOString();

    var order = em.createEntity('Order', {
      customerID: wellKnownData.alfredsID,
      employeeID: wellKnownData.nancyID,
      shipAddress: testAddress
    });
    var saveOptions = new SaveOptions({ resourceName: resourceName, tag: "UpdateProduceShipAddress.Before" });
    
    em.saveChanges(null, saveOptions).then(function (data) {
      // BeforeSaveEntities should have put the testAddress in the description of an Apple
      var emx = new EntityManager({ serviceName: "breeze/ProduceTPH" });
      var q = EntityQuery.from("Apples").where("description", "==", testAddress);
      return emx.executeQuery(q);
    }).then(function (data) {
      var results = data.results;
      ok(results.length === 1, "should have returned 1 result");
      var produce = results[0];
      var desc = produce.getProperty("description");
      ok(desc === testAddress, "description should equal testAddress");

    }).fail(testFns.handleFail).fin(done);
  }

  testFns.skipIf("hibernate", "does not YET support saving without a transaction").
  test("save Order and update ShipAddress in ProduceTPH in BeforeSave - SaveWithNoTransaction", function(assert) {
    saveOrderAndUpdateShipAddressBeforeSave(assert, "SaveWithNoTransaction");
  });

  testFns.skipIf("hibernate", "TODO - need to add the ProduceTPH model for this test").
  test("save Order and update ShipAddress in ProduceTPH in BeforeSave - SaveWithDbTransaction", function (assert) {
    saveOrderAndUpdateShipAddressBeforeSave(assert, "SaveWithDbTransaction");
  });

  testFns.skipIf("hibernate", "does not distinguish between different types of transaction support").
  test("save Order and update ShipAddress in ProduceTPH in BeforeSave - SaveWithTransactionScope - DTC", function(assert) {
    saveOrderAndUpdateShipAddressBeforeSave(assert, "SaveWithTransactionScope");
  });

  function saveOrderAddKeyMappingToCommentAfterSave(assert, resourceName) {
    var done = assert.async();
    var em = newEm();
    var testComment;
    var order = em.createEntity('Order', {
      customerID: wellKnownData.alfredsID,
      employeeID: wellKnownData.nancyID,
      shipAddress: "Test " + new Date().toISOString()
    });
    var saveOptions = new SaveOptions({ resourceName: resourceName, tag: "CommentKeyMappings.After" });
    
    em.saveChanges(null, saveOptions).then(function (data) {
      // AfterSaveEntities should have put the order type and id in a comment
      var orderId = order.getProperty("orderID");
      var type = order.entityType;
      testComment = type.namespace + '.' + type.shortName + ':' + orderId;

      var em2 = newEm();
      var q = EntityQuery.from("Comments").where("comment1", "==", testComment);
      return em2.executeQuery(q);
    }).then(function (data) {
      var results = data.results;
      ok(results.length === 1, "should have returned 1 result");
      var comment = results[0];
      var comment1 = comment.getProperty("comment1");
      ok(comment1 === testComment, "comment should equal testComment");

    }).fail(testFns.handleFail).fin(done);
  }

  testFns.skipIf("hibernate", "does not YET support saving without a transaction").
  test("save Order and add KeyMapping to Comment in AfterSave - SaveWithNoTransaction", function(assert) {
    saveOrderAddKeyMappingToCommentAfterSave(assert, "SaveWithNoTransaction");
  });

  testFns.skipIf("hibernate", "TODO: does not YET support adding data in afterSaveEntities").
  test("save Order and add KeyMapping to Comment in AfterSave - SaveWithDbTransaction", function (assert) {
    saveOrderAddKeyMappingToCommentAfterSave(assert, "SaveWithDbTransaction");
  });

  testFns.skipIf("hibernate", "does not distinguish between different types of transaction support").
  test("save Order and add KeyMapping to Comment in AfterSave - SaveWithTransactionScope", function (assert) {
    saveOrderAddKeyMappingToCommentAfterSave(assert, "SaveWithTransactionScope");
  });

  function saveOrderUpdateKeyMappingInProduceTPHAfterSave(assert, resourceName) {
    var done = assert.async();
    var em = newEm();
    var testComment;
    var order = em.createEntity('Order', {
      customerID: wellKnownData.alfredsID,
      employeeID: wellKnownData.nancyID,
      shipAddress: "Test " + new Date().toISOString()
    });
    var saveOptions = new SaveOptions({ tag: "UpdateProduceKeyMapping.After" });
    
    em.saveChanges(null, saveOptions).then(function (data) {
      // AfterSaveEntities should have put the order type and id in the description of an Apple
      var orderId = order.getProperty("orderID");
      var type = order.entityType;
      testComment = type.namespace + '.' + type.shortName + ':' + orderId;

      var emx = new EntityManager({ serviceName: "breeze/ProduceTPH" });
      var q = EntityQuery.from("Apples").where("description", "==", testComment);
      return emx.executeQuery(q);
    }).then(function (data) {
      var results = data.results;
      ok(results.length === 1, "should have returned 1 result");
      var produce = results[0];
      var desc = produce.getProperty("description");
      ok(desc === testComment, "description should equal testComment");

    }).fail(testFns.handleFail).fin(done);
  }

  testFns.skipIf("hibernate", "does not YET support saving without a transaction").
  test("save Order and update KeyMapping in ProduceTPH in AfterSave - SaveWithNoTransaction", function (assert) {
    saveOrderUpdateKeyMappingInProduceTPHAfterSave(assert, "SaveWithNoTransaction");
  });

  testFns.skipIf("hibernate", "TODO - need to add the ProduceTPH model for this test").
  test("save Order and update KeyMapping in ProduceTPH in AfterSave - SaveWithDbTransaction", function (assert) {
    saveOrderUpdateKeyMappingInProduceTPHAfterSave(assert, "SaveWithDbTransaction");
  });

  testFns.skipIf("hibernate", "does not distinguish between different types of transaction support").
  test("save Order and update KeyMapping in ProduceTPH in AfterSave - SaveWithTransactionScope", function (assert) {
    saveOrderUpdateKeyMappingInProduceTPHAfterSave(assert, "SaveWithTransactionScope");  // DTC iff database != SQL 2008+
  });

  function saveOrderWithLookupInSecondContext(assert, resourceName, tag) {
    var done = assert.async();
    var em = newEm();
    var testComment;
    var order = em.createEntity('Order', {
      customerID: wellKnownData.alfredsID,
      employeeID: wellKnownData.nancyID,
      shipAddress: "Test " + new Date().toISOString()
    });
    var saveOptions = new SaveOptions({ resourceName: resourceName, tag: tag });
    
    em.saveChanges(null, saveOptions).then(function (data) {
      // should have put the order type and id in a comment
      var orderId = order.getProperty("orderID");
      var employeeId = order.getProperty("employeeID");
      ok(employeeId == wellKnownData.nancyID);

    }).fail(testFns.handleFail).fin(done);
  }

  testFns.skipIf("hibernate", "does not YET support saving without a transaction").
  test("save Order with lookup in second Context in BeforeSave - SaveWithNoTransaction", function (assert) {
    saveOrderWithLookupInSecondContext(assert, "SaveWithNoTransaction", "LookupEmployeeInSeparateContext.Before");
  });

  testFns.skipIf("hibernate", "does not YET support operations in a separate context").
  test("save Order with lookup in second Context in BeforeSave - SaveWithDbTransaction", function (assert) {
    saveOrderWithLookupInSecondContext(assert, "SaveWithDbTransaction", "LookupEmployeeInSeparateContext.Before");
  });

  testFns.skipIf("hibernate", "does not distinguish between different types of transaction support").
  test("save Order with lookup in second Context in BeforeSave - SaveWithTransactionScope - DTC", function (assert) {
    saveOrderWithLookupInSecondContext(assert, "SaveWithTransactionScope", "LookupEmployeeInSeparateContext.Before");
  });

  testFns.skipIf("hibernate", "does not YET support saving without a transaction").
  test("save Order with lookup in second Context in BeforeSave - Same Connection - SaveWithNoTransaction", function (assert) {
    saveOrderWithLookupInSecondContext(assert, "SaveWithNoTransaction", "LookupEmployeeInSeparateContext.SameConnection.Before");
  });

  testFns.skipIf("hibernate", "does not YET support operations in a separate context").
  test("save Order with lookup in second Context in BeforeSave - Same Connection- SaveWithDbTransaction", function (assert) {
    saveOrderWithLookupInSecondContext(assert, "SaveWithDbTransaction", "LookupEmployeeInSeparateContext.SameConnection.Before");
  });

  testFns.skipIf("hibernate", "does not distinguish between different types of transaction support").
  test("save Order with lookup in second Context in BeforeSave - Same Connection- SaveWithTransactionScope", function (assert) {
    saveOrderWithLookupInSecondContext(assert,"SaveWithTransactionScope", "LookupEmployeeInSeparateContext.SameConnection.Before");
  });

  testFns.skipIf("hibernate", "does not YET support saving without a transaction").
  test("save Order with lookup in second Context in AfterSave - SaveWithNoTransaction", function (assert) {
    saveOrderWithLookupInSecondContext(assert,"SaveWithNoTransaction", "LookupEmployeeInSeparateContext.After");
  });

  testFns.skipIf("hibernate", "does not YET support operations in a separate context").
  test("save Order with lookup in second Context in AfterSave - SaveWithDbTransaction", function (assert) {
    saveOrderWithLookupInSecondContext(assert, "SaveWithDbTransaction", "LookupEmployeeInSeparateContext.After");
  });

  testFns.skipIf("hibernate", "does not distinguish between different types of transaction support").
  test("save Order with lookup in second Context in AfterSave - SaveWithTransactionScope - DTC", function (assert) {
    saveOrderWithLookupInSecondContext(assert, "SaveWithTransactionScope", "LookupEmployeeInSeparateContext.After");
  });

  testFns.skipIf("hibernate", "does not YET support saving without a transaction").
  test("save Order with lookup in second Context in AfterSave - Same Connection- SaveWithNoTransaction", function (assert) {
    saveOrderWithLookupInSecondContext(assert, "SaveWithNoTransaction", "LookupEmployeeInSeparateContext.SameConnection.After");
  });

  testFns.skipIf("hibernate", "does not YET support operations in a separate context").
  test("save Order with lookup in second Context in AfterSave - Same Connection- SaveWithDbTransaction", function (assert) {
    saveOrderWithLookupInSecondContext(assert, "SaveWithDbTransaction", "LookupEmployeeInSeparateContext.SameConnection.After");
  });

  testFns.skipIf("hibernate", "does not distinguish between different types of transaction support").
  test("save Order with lookup in second Context in AfterSave - Same Connection- SaveWithTransactionScope", function (assert) {
    saveOrderWithLookupInSecondContext(assert, "SaveWithTransactionScope", "LookupEmployeeInSeparateContext.SameConnection.After");
  });


})(breezeTestFns);